<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Legends</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 640px;
            height: 480px;
            background: #0f0f1a;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: white;
            background: #0f0f1a;
            overflow: auto;
        }

        .screen.active {
            display: flex;
        }

        #overworld-screen,
        #dungeon-screen,
        #magic-puzzle-screen,
        #dungeon-strength-screen,
        #dungeon-defense-screen,
        #dungeon-bomb-screen {
            display: none;
        }

        #overworld-screen.active,
        #dungeon-screen.active,
        #magic-puzzle-screen.active,
        #dungeon-strength-screen.active,
        #dungeon-defense-screen.active,
        #dungeon-bomb-screen.active {
            display: block;
        }

        #overworld-canvas,
        #dungeon-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        h1 {
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ffcc00;
        }

        h2 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #ffcc00;
        }

        button {
            background: linear-gradient(to bottom, #4a4a8f, #2a2a5f);
            color: white;
            border: 2px solid #6a6acc;
            padding: 10px 20px;
            margin: 10px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
        }

        button:hover {
            background: linear-gradient(to bottom, #5a5aaf, #3a3a7f);
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.95);
        }

        .menu-btn {
            width: 200px;
            height: 40px;
            font-size: 18px;
            margin: 10px 0;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 36px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            font-size: 14px;
            z-index: 100;
            display: none;
        }

        #hud.active {
            display: block;
        }

        #dialogue-box {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 20px;
            display: none;
            z-index: 100;
        }

        #dialogue-box.active {
            display: block;
        }

        #quest-panel {
            position: absolute;
            top: 40px;
            right: 10px;
            width: 190px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border: 2px solid #ffcc00;
            border-radius: 5px;
            display: none;
            z-index: 90;
        }

        #quest-panel.active {
            display: block;
        }

        .quest-title {
            color: #ffcc00;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .quest-progress {
            font-size: 12px;
            margin-bottom: 10px;
        }

        .menu-item {
            padding: 8px 15px;
            margin: 2px 0;
            cursor: pointer;
            border-radius: 3px;
        }

        .menu-item.selected {
            background: #ffcc00;
            color: #000;
            font-weight: bold;
        }

        .menu-item:hover:not(.selected) {
            background: rgba(255, 204, 0, 0.3);
        }

        #battle-screen {
            text-align: center;
        }

        .battle-stats {
            margin-bottom: 20px;
            text-align: left;
            width: 100%;
            padding: 10px;
            background: rgba(30, 30, 60, 0.8);
            border-radius: 5px;
        }

        .enemy-display {
            width: 100px;
            height: 100px;
            margin: 20px auto;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            position: relative;
        }

        .enemy-name {
            position: absolute;
            top: -20px;
            width: 100px;
            text-align: center;
            font-size: 12px;
        }

        .enemy-hp {
            position: absolute;
            bottom: -20px;
            width: 100px;
            text-align: center;
            font-size: 12px;
        }

        .player-stats {
            margin: 15px 0;
            text-align: left;
        }

        .battle-menu {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 140px;
            background: rgba(20, 20, 20, 0.95);
            padding: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .battle-message {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            white-space: pre-line;
            text-align: left;
        }

        .battle-message .continue {
            margin-top: 10px;
            color: #aaa;
            font-size: 12px;
        }

        #inventory-screen,
        #shop-screen {
            text-align: left;
            padding: 20px;
            overflow-y: auto;
            height: 100%;
        }

        .item-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 5px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .item {
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
        }

        .item.selected {
            background: #ffcc00;
            color: #000;
            font-weight: bold;
        }

        .item.equipped {
            position: relative;
        }

        .item.equipped::after {
            content: " [E]";
            color: #ff6666;
            font-weight: bold;
        }

        .item-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(30, 30, 60, 0.8);
            border-radius: 5px;
        }

        .footer-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            color: #66ff66;
            text-align: center;
            font-size: 14px;
        }

        #slay-map-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #slay-map-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .map-hud {
            position: absolute;
            top: 0;
            left: 0;
            width: calc(100% - 20px);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 5px 10px;
            font-size: 14px;
            z-index: 10;
        }

        #victory-screen,
        #game-beat-screen,
        #slay-act-clear-screen {
            background: linear-gradient(to bottom, #2a1a3a, #1a0a2a);
        }

        .shake {
            animation: shake 0.2s;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-5px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(5px);
            }
        }

        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0.5;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #4a4a8f;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6a6acc;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <!-- HUD -->
        <div id="hud">
            <span id="hud-text">Move: Arrow/WASD | Talk: SPACE | Menu: ESC | I: Inventory</span>
        </div>
        <!-- Dialogue Box -->
        <div id="dialogue-box">
            <div id="dialogue-text">Hello traveler!</div>
            <div style="margin-top: 10px; color: #aaa; font-size: 12px;">[SPACE] to continue</div>
        </div>
        <!-- Quest Panel -->
        <div id="quest-panel">
            <div class="quest-title">Active Quests:</div>
            <div id="quest-list"></div>
        </div>
        <!-- Menu Screen -->
        <div id="menu-screen" class="screen">
            <h1>Dungeon Legends</h1>
            <button id="start-btn" class="menu-btn">Start / Continue</button>
            <button id="board-game-btn" class="menu-btn">Play Board Game Mode</button>
            <button id="quit-btn" class="menu-btn">Quit</button>
            <div style="margin-top: 30px; text-align: left; width: 80%;">
                <div>Player Gold: <span id="menu-gold">0</span>g</div>
                <div>Player HP: <span id="menu-hp">0</span>/<span id="menu-maxhp">0</span></div>
                <div>Bosses Defeated: <span id="menu-bosses">0</span>/5</div>
            </div>
        </div>
        <!-- Overworld Screen -->
        <div id="overworld-screen" class="screen">
            <canvas id="overworld-canvas" width="640" height="480"></canvas>
        </div>
        <!-- Battle Screen -->
        <div id="battle-screen" class="screen">
            <div class="battle-stats">
                <div class="enemy-name" id="enemy-name">Enemy</div>
                <div class="enemy-display" id="enemy-display"></div>
                <div class="enemy-hp" id="enemy-hp">HP: 0/0</div>
                <div class="player-stats">
                    <div>Player HP: <span id="player-hp">0</span>/<span id="player-maxhp">0</span></div>
                    <div>LV: <span id="player-lv">1</span> | ATK: <span id="player-atk">0</span></div>
                    <div>EXP: <span id="player-exp">0</span>/<span id="player-exp-max">60</span></div>
                    <div>Gold: <span id="player-gold">0</span>g</div>
                </div>
            </div>
            <div class="battle-menu" id="battle-menu">
                <div class="menu-item selected" data-action="attack">Attack</div>
                <div class="menu-item" data-action="magic">Magic</div>
                <div class="menu-item" data-action="potion">Potion</div>
                <div class="menu-item" data-action="bomb">Bomb</div>
                <div class="menu-item" data-action="run">Run</div>
            </div>
            <div class="battle-message" id="battle-message" style="display: none;">
                <div id="battle-message-text">A wild enemy appeared!</div>
                <div class="continue">[SPACE/ENTER] to continue</div>
            </div>
        </div>
        <!-- Inventory Screen -->
        <div id="inventory-screen" class="screen">
            <h2>Inventory</h2>
            <div class="item-list" id="inventory-list"></div>
            <div class="item-info" id="inventory-info">
                <div>Active Gear: Wpn: <span id="equipped-weapon">None</span> | Arm: <span
                        id="equipped-armor">None</span></div>
                <div>Spells: <span id="spell-count">0</span>/3 | Potions: <span id="potion-count">0</span>/4 | Bombs:
                    <span id="bomb-count">0</span>/4
                </div>
                <div id="inventory-message" style="color: #66ff66; margin-top: 10px;"></div>
            </div>
            <div class="footer-info">Enter = Equip | U = Unequip | ESC = Back</div>
        </div>
        <!-- Shop Screen -->
        <div id="shop-screen" class="screen">
            <h2>Shop</h2>
            <div style="margin-bottom: 10px;">
                <span id="shop-gold">Gold: 0g</span> |
                <button id="toggle-shop-mode">Switch to Sell Mode</button>
                <button id="shop-inventory-btn" style="margin-left: 10px; font-size: 12px;">Inventory (I)</button>
            </div>
            <div class="item-list" id="shop-list"></div>
            <div class="item-info" id="shop-info"></div>
            <div class="footer-info" id="shop-footer">UP/DOWN: Browse | ENTER: Buy | T: Toggle Mode | ESC: Back</div>
        </div>
        <!-- Dungeon Screens -->
        <div id="dungeon-screen" class="screen">
            <canvas id="dungeon-canvas" width="640" height="480"></canvas>
        </div>
        <div id="magic-puzzle-screen" class="screen">
            <canvas id="magic-puzzle-canvas" width="640" height="480"></canvas>
        </div>
        <div id="dungeon-strength-screen" class="screen">
            <canvas id="dungeon-strength-canvas" width="640" height="480"></canvas>
        </div>
        <div id="dungeon-defense-screen" class="screen">
            <canvas id="dungeon-defense-canvas" width="640" height="480"></canvas>
        </div>
        <div id="dungeon-bomb-screen" class="screen">
            <canvas id="dungeon-bomb-canvas" width="640" height="480"></canvas>
        </div>
        <!-- Slay Map Screen -->
        <div id="slay-map-screen" class="screen">
            <div id="slay-map-container">
                <canvas id="slay-map-canvas" width="640" height="480"></canvas>
                <div class="map-hud" id="map-hud">Act 1 | Scroll: Mouse Wheel | Select: Arrows + Space | I: Inventory |
                    P: Shop</div>
            </div>
        </div>
        <!-- Slay Act Clear Screen -->
        <div id="slay-act-clear-screen" class="screen">
            <h1 style="color: #ff6666; text-shadow: 0 0 15px #ff6666;">ACT CLEARED!</h1>
            <h2 id="act-clear-info">You have defeated the boss.</h2>
            <button id="next-act-btn" class="menu-btn">Enter Next Act</button>
        </div>
        <!-- Victory Screen -->
        <div id="victory-screen" class="screen">
            <h1 style="color: #66ff66;">You Won!</h1>
            <button id="victory-return-btn" class="menu-btn">Return to Menu</button>
        </div>
        <!-- Game Beat Screen -->
        <div id="game-beat-screen" class="screen">
            <h1 style="color: #ff66ff; text-shadow: 0 0 20px #ff66ff;">You Beat The Game!</h1>
            <button id="game-beat-exit-btn" class="menu-btn">Exit Game</button>
        </div>
    </div>
    <script>
        // ==================== GAME ENGINE ====================
        class Game {
            constructor() {
                this.currentScreen = 'menu';
                this.screens = {};
                this.player = new Player();
                this.overworld = new Overworld(this);
                this.battle = new Battle(this);
                this.inventory = new Inventory(this);
                this.shop = new Shop(this);
                this.dungeon = new Dungeon(this);
                this.magicPuzzle = new MagicPuzzle(this);
                this.dungeonStrength = new DungeonStrength(this);
                this.dungeonDefense = new DungeonDefense(this);
                this.dungeonBomb = new DungeonBomb(this);
                this.slayMap = new SlayMap(this);
                this.slayActClear = new SlayActClearScreen(this);
                this.victory = new VictoryScreen(this);
                this.gameBeat = new GameBeatScreen(this);
                this.returnScreen = 'overworld';
                this.lastScreen = 'overworld';
                this.lastNpcX = -1;
                this.lastNpcY = -1;
                this.defeatedBosses = new Set();
                this.audioContext = null;
                this.sounds = {};
                this.music = null;
                this.isMusicPlaying = false;
                this.init();
            }
            init() {
                // Initialize audio
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext();
                } catch (e) {
                    console.log("Web Audio API not supported");
                }
                // Setup screens
                this.screens = {
                    'menu': document.getElementById('menu-screen'),
                    'overworld': document.getElementById('overworld-screen'),
                    'battle': document.getElementById('battle-screen'),
                    'inventory': document.getElementById('inventory-screen'),
                    'shop': document.getElementById('shop-screen'),
                    'dungeon': document.getElementById('dungeon-screen'),
                    'magic-puzzle': document.getElementById('magic-puzzle-screen'),
                    'dungeon-strength': document.getElementById('dungeon-strength-screen'),
                    'dungeon-defense': document.getElementById('dungeon-defense-screen'),
                    'dungeon-bomb': document.getElementById('dungeon-bomb-screen'),
                    'slay-map': document.getElementById('slay-map-screen'),
                    'slay-act-clear': document.getElementById('slay-act-clear-screen'),
                    'victory': document.getElementById('victory-screen'),
                    'game-beat': document.getElementById('game-beat-screen')
                };
                // HUD elements
                this.hud = document.getElementById('hud');
                this.dialogueBox = document.getElementById('dialogue-box');
                this.questPanel = document.getElementById('quest-panel');
                // Show menu screen
                this.showScreen('menu');
                // Setup event listeners
                this.setupEventListeners();
                // Load game if exists
                this.loadGame();
            }
            setupEventListeners() {
                // Menu buttons
                document.getElementById('start-btn').addEventListener('click', () => {
                    this.showScreen('overworld');
                });
                document.getElementById('board-game-btn').addEventListener('click', () => {
                    this.slayMap.resetRun();
                    this.showScreen('slay-map');
                });
                document.getElementById('quit-btn').addEventListener('click', () => {
                    if (confirm('Are you sure you want to quit?')) {
                        window.close();
                    }
                });
                // Victory button
                document.getElementById('victory-return-btn').addEventListener('click', () => {
                    this.showScreen('menu');
                });
                // Game Beat button
                document.getElementById('game-beat-exit-btn').addEventListener('click', () => {
                    window.close();
                });
                // Slay Act Clear button
                document.getElementById('next-act-btn').addEventListener('click', () => {
                    this.slayMap.startNextAct();
                    this.showScreen('slay-map');
                });
                // Shop toggle button
                document.getElementById('toggle-shop-mode').addEventListener('click', () => {
                    this.shop.toggleMode();
                });
                document.getElementById('shop-inventory-btn').addEventListener('click', () => {
                    this.showScreen('inventory');
                });
                // Keyboard events
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
                // Battle menu clicks
                document.querySelectorAll('#battle-menu .menu-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        if (this.currentScreen === 'battle' && !this.battle.showingMessage && this.battle.waitingForPlayer) {
                            const action = e.target.dataset.action;
                            this.battle.selectAction(action);
                        }
                    });
                });
                // Mouse wheel for Slay Map
                document.getElementById('slay-map-canvas').addEventListener('wheel', (e) => {
                    if (this.currentScreen === 'slay-map') {
                        this.slayMap.handleWheel(e);
                    }
                });
                // Click for Slay Map
                document.getElementById('slay-map-canvas').addEventListener('click', (e) => {
                    if (this.currentScreen === 'slay-map') {
                        this.slayMap.handleClick(e);
                    }
                });
                // Inventory item clicks
                document.getElementById('inventory-list').addEventListener('click', (e) => {
                    if (e.target.classList.contains('item')) {
                        const index = parseInt(e.target.dataset.index);
                        if (!isNaN(index)) {
                            this.inventory.selectItem(index);
                        }
                    }
                });
                // Shop item clicks
                document.getElementById('shop-list').addEventListener('click', (e) => {
                    if (e.target.classList.contains('item')) {
                        const index = parseInt(e.target.dataset.index);
                        if (!isNaN(index)) {
                            this.shop.selectItem(index);
                        }
                    }
                });
            }
            handleKeyDown(e) {
                // Global shortcuts
                if (e.key === 'Escape') {
                    if (this.currentScreen === 'overworld' || this.currentScreen === 'slay-map') {
                        this.showScreen('menu');
                    } else if (this.currentScreen === 'inventory' || this.currentScreen === 'shop') {
                        this.showScreen(this.lastScreen);
                    } else if (this.currentScreen === 'battle') {
                        if (this.battle.waitingForPlayer && !this.battle.showingMessage &&
                            !this.battle.selectingSpell && !this.battle.selectingPotion && !this.battle.selectingBomb) {
                            this.battle.attemptRun();
                        }
                    }
                }
                if (e.key === 'i' || e.key === 'I') {
                    if (this.currentScreen !== 'inventory' && this.currentScreen !== 'shop') {
                        this.lastScreen = this.currentScreen;
                        this.showScreen('inventory');
                    }
                }
                if (e.key === 'p' || e.key === 'P') {
                    if (this.currentScreen === 'slay-map') {
                        this.lastScreen = 'slay-map';
                        this.showScreen('shop');
                    }
                }
                // Screen-specific controls
                switch (this.currentScreen) {
                    case 'menu':
                        if (e.key === 'Enter') {
                            this.showScreen('overworld');
                        }
                        break;
                    case 'overworld':
                        this.overworld.handleKeyDown(e);
                        break;
                    case 'battle':
                        this.battle.handleKeyDown(e);
                        break;
                    case 'inventory':
                        this.inventory.handleKeyDown(e);
                        break;
                    case 'shop':
                        this.shop.handleKeyDown(e);
                        break;
                    case 'dungeon':
                    case 'magic-puzzle':
                    case 'dungeon-strength':
                    case 'dungeon-defense':
                    case 'dungeon-bomb':
                        const dungeon = this.getDungeonScreen();
                        if (dungeon) dungeon.handleKeyDown(e);
                        break;
                    case 'slay-map':
                        this.slayMap.handleKeyDown(e);
                        break;
                }
            }
            handleKeyUp(e) {
                // Handle key releases if needed
            }
            getDungeonScreen() {
                switch (this.currentScreen) {
                    case 'dungeon': return this.dungeon;
                    case 'magic-puzzle': return this.magicPuzzle;
                    case 'dungeon-strength': return this.dungeonStrength;
                    case 'dungeon-defense': return this.dungeonDefense;
                    case 'dungeon-bomb': return this.dungeonBomb;
                    default: return null;
                }
            }
            showScreen(screenName) {
                // Hide current screen
                if (this.screens[this.currentScreen]) {
                    this.screens[this.currentScreen].classList.remove('active');
                }
                // Stop music
                this.stopMusic();
                // Show new screen
                this.currentScreen = screenName;
                this.screens[screenName].classList.add('active');
                // Remember last non-inventory screen
                if (screenName !== 'inventory' && screenName !== 'shop') {
                    this.lastScreen = screenName;
                }
                // Update HUD visibility
                this.hud.classList.toggle('active',
                    screenName === 'overworld' || screenName === 'dungeon' ||
                    screenName === 'magic-puzzle' || screenName === 'dungeon-strength' ||
                    screenName === 'dungeon-defense' || screenName === 'dungeon-bomb');
                // Update dialogue box
                this.dialogueBox.classList.remove('active');
                // Update quest panel
                this.updateQuestPanel();
                // Screen-specific onShow logic
                switch (screenName) {
                    case 'menu':
                        this.playMusic('menu');
                        document.getElementById('menu-gold').textContent = this.player.gold;
                        document.getElementById('menu-hp').textContent = this.player.currentHP;
                        document.getElementById('menu-maxhp').textContent = this.player.getMaxHP();
                        document.getElementById('menu-bosses').textContent = this.getDefeatedBossCount();
                        break;
                    case 'overworld':
                        this.playMusic('overworld');
                        this.overworld.onShow();
                        break;
                    case 'battle':
                        this.playMusic('battle');
                        this.battle.startBattle();
                        break;
                    case 'inventory':
                        this.inventory.onShow();
                        break;
                    case 'shop':
                        this.playMusic('shop');
                        this.shop.onShow();
                        break;
                    case 'dungeon':
                        this.dungeon.onShow();
                        break;
                    case 'magic-puzzle':
                        this.magicPuzzle.onShow();
                        break;
                    case 'dungeon-strength':
                        this.dungeonStrength.onShow();
                        break;
                    case 'dungeon-defense':
                        this.dungeonDefense.onShow();
                        break;
                    case 'dungeon-bomb':
                        this.dungeonBomb.onShow();
                        break;
                    case 'slay-map':
                        this.playMusic('overworld');
                        this.slayMap.onShow();
                        break;
                    case 'slay-act-clear':
                        this.slayActClear.onShow();
                        break;
                    case 'victory':
                        this.victory.onShow();
                        break;
                    case 'game-beat':
                        this.gameBeat.onShow();
                        break;
                }
                console.log(`[DEBUG] Switched to screen: ${screenName}`);
            }
            showDialogue(text, pendingAction = null) {
                document.getElementById('dialogue-text').textContent = text;
                this.dialogueBox.classList.add('active');
                this.overworld.pendingAction = pendingAction;
            }
            hideDialogue() {
                this.dialogueBox.classList.remove('active');
                this.overworld.pendingAction = null;
            }
            updateQuestPanel() {
                const questList = document.getElementById('quest-list');
                if (this.player.activeQuests.length > 0) {
                    let html = '';
                    this.player.activeQuests.forEach(quest => {
                        html += `<div class="quest-progress">${quest.name}<br>${quest.getProgress()}</div>`;
                    });
                    questList.innerHTML = html;
                    this.questPanel.classList.add('active');
                } else {
                    this.questPanel.classList.remove('active');
                }
            }
            addDefeatedBoss(bossId) {
                this.defeatedBosses.add(bossId);
                console.log(`[DEBUG] Defeated boss ID ${bossId}. Total defeated: ${this.defeatedBosses.size}`);
                this.updateQuestPanel();
            }
            getDefeatedBossCount() {
                return this.defeatedBosses.size;
            }
            resetGame() {
                this.player.reset();
                this.overworld.resetPlayerPosition();
                this.dungeon.reset();
                this.magicPuzzle.reset();
                this.dungeonStrength.reset();
                this.dungeonDefense.reset();
                this.dungeonBomb.reset();
                this.defeatedBosses.clear();
                this.slayMap.resetRun();
                this.shop.resetShop();
                console.log('[DEBUG] Game state has been reset.');
            }
            // Audio methods
            playSound(name) {
                if (!this.audioContext) return;
                // Create simple sounds using oscillators
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                switch (name) {
                    case 'attack':
                        oscillator.frequency.value = 440;
                        gainNode.gain.value = 0.1;
                        oscillator.type = 'square';
                        break;
                    case 'potion':
                        oscillator.frequency.value = 880;
                        gainNode.gain.value = 0.05;
                        oscillator.type = 'sine';
                        break;
                    case 'magic':
                        oscillator.frequency.value = 660;
                        gainNode.gain.value = 0.15;
                        oscillator.type = 'triangle';
                        break;
                    case 'bomb':
                        oscillator.frequency.value = 220;
                        gainNode.gain.value = 0.3;
                        oscillator.type = 'sawtooth';
                        break;
                    case 'victory':
                        oscillator.frequency.value = 1320;
                        gainNode.gain.value = 0.2;
                        oscillator.type = 'sine';
                        break;
                    case 'defeat':
                        oscillator.frequency.value = 110;
                        gainNode.gain.value = 0.2;
                        oscillator.type = 'square';
                        break;
                    case 'esc':
                        oscillator.frequency.value = 550;
                        gainNode.gain.value = 0.1;
                        oscillator.type = 'sine';
                        break;
                    case 'mustfight':
                        oscillator.frequency.value = 220;
                        gainNode.gain.value = 0.15;
                        oscillator.type = 'square';
                        break;
                    case 'switch':
                        oscillator.frequency.value = 330;
                        gainNode.gain.value = 0.1;
                        oscillator.type = 'triangle';
                        break;
                    case 'puzzlesolved':
                        oscillator.frequency.value = 880;
                        gainNode.gain.value = 0.2;
                        oscillator.type = 'sine';
                        break;
                    default:
                        oscillator.frequency.value = 440;
                        gainNode.gain.value = 0.1;
                        oscillator.type = 'sine';
                }
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.2);
            }
            playMusic(trackName) {
                // For simplicity, we won't implement full background music
                // In a real game, you'd use HTML5 Audio elements
                this.isMusicPlaying = true;
            }
            stopMusic() {
                this.isMusicPlaying = false;
            }
            shake(duration, intensity) {
                const container = document.getElementById('game-container');
                container.classList.add('shake');
                setTimeout(() => {
                    container.classList.remove('shake');
                }, duration);
            }
            // Save/Load
            saveGame() {
                const saveData = {
                    player: this.player.save(),
                    defeatedBosses: Array.from(this.defeatedBosses),
                    overworld: this.overworld.save(),
                    slayMap: this.slayMap.save()
                };
                localStorage.setItem('dungeonLegendsSave', JSON.stringify(saveData));
                console.log('[DEBUG] Game saved');
            }
            loadGame() {
                const saveData = localStorage.getItem('dungeonLegendsSave');
                if (saveData) {
                    try {
                        const data = JSON.parse(saveData);
                        this.player.load(data.player);
                        this.defeatedBosses = new Set(data.defeatedBosses || []);
                        if (data.overworld) this.overworld.load(data.overworld);
                        if (data.slayMap) this.slayMap.load(data.slayMap);
                        console.log('[DEBUG] Game loaded');
                    } catch (e) {
                        console.error('Error loading save:', e);
                    }
                }
            }
        }
        // ==================== PLAYER ====================
        class Player {
            constructor() {
                this.potions = 0;
                this.bombs = 0;
                this.gold = 0;
                this.baseMaxHP = 20;
                this.currentHP = this.baseMaxHP;
                this.baseAttack = 5;
                this.equippedSpells = [];
                this.equippedPotions = [];
                this.equippedBombs = [];
                this.equippedItem = null;
                this.equippedWeapon = null;
                this.equippedArmor = null;
                this.inventory = [];
                this.level = 1;
                this.exp = 0;
                this.activeQuests = [];
                this.completedQuests = [];
                this.DonationStage = 0;
                this.reset();
            }
            reset() {
                this.gold = 0;
                this.baseMaxHP = 20;
                this.baseAttack = 5;
                this.level = 1;
                this.exp = 0;
                this.currentHP = this.baseMaxHP;
                this.equippedWeapon = null;
                this.equippedArmor = null;
                this.inventory = [];
                this.equippedSpells = [];
                this.equippedPotions = [];
                this.equippedBombs = [];
                this.activeQuests = [];
                this.completedQuests = [];
                this.DonationStage = 0;
                this.addItem(new Item("Potion", 10, true, false, 15, 0, 0, "Potion", null));
            }
            getMaxHP() {
                let bonus = 0;
                if (this.equippedArmor) bonus += this.equippedArmor.hpBonus;
                return this.baseMaxHP + bonus;
            }
            getAttack() {
                let bonus = 0;
                if (this.equippedWeapon) bonus += this.equippedWeapon.attackBonus;
                return this.baseAttack + bonus;
            }
            restoreToMax() {
                this.currentHP = this.getMaxHP();
            }
            addItem(item) {
                this.inventory.push(item);
            }
            removeItem(item) {
                const index = this.inventory.findIndex(i => i.uniqueId === item.uniqueId);
                if (index !== -1) {
                    this.inventory.splice(index, 1);
                }
            }
            equip(item) {
                if (item.isWeapon()) {
                    this.equippedWeapon = item;
                } else if (item.isArmor()) {
                    this.equippedArmor = item;
                } else if (item.isSpell()) {
                    if (this.equippedSpells.some(s => s.uniqueId === item.uniqueId)) {
                        return;
                    }
                    if (item.element && item.element !== "Heal") {
                        if (this.equippedSpells.some(s => s.element === item.element)) {
                            return;
                        }
                    }
                    if (this.equippedSpells.length < 3) {
                        this.equippedSpells.push(item);
                    }
                } else if (item.type === "Bomb") {
                    if (this.equippedBombs.some(b => b.uniqueId === item.uniqueId)) {
                        return;
                    }
                    if (this.equippedBombs.length < 4) {
                        this.equippedBombs.push(item);
                    }
                } else if (item.consumable) {
                    if (this.equippedPotions.some(p => p.uniqueId === item.uniqueId)) {
                        return;
                    }
                    if (this.equippedPotions.length < 4) {
                        this.equippedPotions.push(item);
                    }
                }
            }
            unequipSpell(spell) {
                this.equippedSpells = this.equippedSpells.filter(s => s.uniqueId !== spell.uniqueId);
            }
            unequipPotion(potion) {
                this.equippedPotions = this.equippedPotions.filter(p => p.uniqueId !== potion.uniqueId);
            }
            unequipBomb(bomb) {
                this.equippedBombs = this.equippedBombs.filter(b => b.uniqueId !== bomb.uniqueId);
            }
            unequipWeapon() {
                this.equippedWeapon = null;
            }
            unequipArmor() {
                this.equippedArmor = null;
            }
            gainExp(amount) {
                this.exp += amount;
                console.log(`[DEBUG] Player gained ${amount} EXP (total ${this.exp})`);
                if (this.exp >= this.level * 60) {
                    this.level++;
                    this.exp = 0;
                    this.baseMaxHP += 4;
                    this.baseAttack += 2;
                    this.currentHP = this.getMaxHP();
                    console.log(`[DEBUG] Player leveled up! Now level ${this.level}`);
                }
            }
            addQuest(quest) {
                if (!this.activeQuests.some(q => q.name === quest.name)) {
                    this.activeQuests.push(quest);
                }
            }
            completeQuest(quest) {
                if (quest.completed && !quest.turnedIn) {
                    quest.turnedIn = true;
                    this.activeQuests = this.activeQuests.filter(q => q.name !== quest.name);
                    this.completedQuests.push(quest);
                    this.gold += quest.goldReward;
                    this.gainExp(quest.expReward);
                    console.log(`[DEBUG] Quest completed: ${quest.name}`);
                }
            }
            trackMonsterKill(monsterName) {
                console.log(`[DEBUG] Tracking kill for: ${monsterName}`);
                this.activeQuests.forEach(quest => {
                    console.log(`[DEBUG] Checking quest: ${quest.name} target: ${quest.targetMonster}`);
                    if (quest.targetMonster.toLowerCase() === monsterName.toLowerCase() && !quest.completed) {
                        quest.addKill();
                        console.log(`[DEBUG] Quest progress: ${quest.getProgress()} completed=${quest.completed}`);
                    }
                });
            }
            save() {
                return {
                    potions: this.potions,
                    bombs: this.bombs,
                    gold: this.gold,
                    baseMaxHP: this.baseMaxHP,
                    currentHP: this.currentHP,
                    baseAttack: this.baseAttack,
                    equippedWeapon: this.equippedWeapon ? this.equippedWeapon.save() : null,
                    equippedArmor: this.equippedArmor ? this.equippedArmor.save() : null,
                    inventory: this.inventory.map(item => item.save()),
                    level: this.level,
                    exp: this.exp,
                    activeQuests: this.activeQuests.map(q => q.save()),
                    completedQuests: this.completedQuests.map(q => q.save()),
                    DonationStage: this.DonationStage
                };
            }
            load(data) {
                this.potions = data.potions || 0;
                this.bombs = data.bombs || 0;
                this.gold = data.gold || 0;
                this.baseMaxHP = data.baseMaxHP || 20;
                this.currentHP = data.currentHP || this.baseMaxHP;
                this.baseAttack = data.baseAttack || 5;
                this.level = data.level || 1;
                this.exp = data.exp || 0;
                this.DonationStage = data.DonationStage || 0;
                // Reconstruct inventory
                this.inventory = [];
                if (data.inventory) {
                    data.inventory.forEach(itemData => {
                        const item = Item.load(itemData);
                        if (item) this.inventory.push(item);
                    });
                }
                // Reconstruct equipped items
                this.equippedWeapon = null;
                this.equippedArmor = null;
                this.equippedSpells = [];
                this.equippedPotions = [];
                this.equippedBombs = [];
                if (data.equippedWeapon) {
                    const weapon = this.inventory.find(i => i.name === data.equippedWeapon.name);
                    if (weapon) this.equippedWeapon = weapon;
                }
                if (data.equippedArmor) {
                    const armor = this.inventory.find(i => i.name === data.equippedArmor.name);
                    if (armor) this.equippedArmor = armor;
                }
                // Reconstruct quests
                this.activeQuests = [];
                this.completedQuests = [];
                if (data.activeQuests) {
                    data.activeQuests.forEach(qData => {
                        const quest = Quest.load(qData);
                        if (quest) this.activeQuests.push(quest);
                    });
                }
                if (data.completedQuests) {
                    data.completedQuests.forEach(qData => {
                        const quest = Quest.load(qData);
                        if (quest) this.completedQuests.push(quest);
                    });
                }
            }
        }
        // ==================== QUEST ====================
        class Quest {
            constructor(name, description, targetMonster, requiredKills, goldReward, expReward, questType) {
                this.name = name;
                this.description = description;
                this.targetMonster = targetMonster;
                this.requiredKills = requiredKills;
                this.currentKills = 0;
                this.goldReward = goldReward;
                this.expReward = expReward;
                this.completed = false;
                this.turnedIn = false;
                this.questType = questType;
            }
            addKill() {
                if (!this.completed && this.questType === "KILL") {
                    this.currentKills++;
                    if (this.currentKills >= this.requiredKills) {
                        this.completed = true;
                    }
                }
            }
            addDonation(amount) {
                if (!this.completed && this.questType === "GOLD") {
                    this.currentKills = Math.min(this.currentKills + amount, this.requiredKills);
                    if (this.currentKills >= this.requiredKills) {
                        this.completed = true;
                    }
                }
            }
            getProgress() {
                if (this.questType === "KILL") {
                    return `${this.currentKills}/${this.requiredKills} ${this.targetMonster} defeated`;
                } else if (this.questType === "GOLD") {
                    return `${this.currentKills}/${this.requiredKills} gold donated`;
                }
                return `Progress: ${this.currentKills}/${this.requiredKills}`;
            }
            save() {
                return {
                    name: this.name,
                    description: this.description,
                    targetMonster: this.targetMonster,
                    requiredKills: this.requiredKills,
                    currentKills: this.currentKills,
                    goldReward: this.goldReward,
                    expReward: this.expReward,
                    completed: this.completed,
                    turnedIn: this.turnedIn,
                    questType: this.questType
                };
            }
            static load(data) {
                const quest = new Quest(
                    data.name,
                    data.description,
                    data.targetMonster,
                    data.requiredKills,
                    data.goldReward,
                    data.expReward,
                    data.questType
                );
                quest.currentKills = data.currentKills || 0;
                quest.completed = data.completed || false;
                quest.turnedIn = data.turnedIn || false;
                return quest;
            }
        }
        // ==================== ENEMY ====================
        class Enemy {
            constructor(name, maxHP, attack, goldReward, expReward, color, isBoss, canHeal = false, canCharge = false, canEnrage = false) {
                this.name = name;
                this.maxHP = maxHP;
                this.currentHP = maxHP;
                this.attack = attack;
                this.goldReward = goldReward;
                this.expReward = expReward;
                this.color = color;
                this.isBoss = isBoss;
                this.canHeal = canHeal;
                this.canCharge = canCharge;
                this.canEnrage = canEnrage;
                this.healThreshold = Math.floor(maxHP / 3);
                this.enrageThreshold = Math.floor(maxHP / 4);
                this.element = null;
            }
            getAttackDamage(random, enraged, charged, playerLevel) {
                let baseDmg = this.attack;
                if (enraged) baseDmg += 7;
                if (charged) baseDmg += 9;
                return baseDmg + playerLevel;
            }
        }
        // ==================== ENEMY FACTORY ====================
        class EnemyFactory {
            static random = Math.random;
            static createSlime() {
                return new Enemy("Slime", 5 + Math.floor(this.random() * 10), 3 + Math.floor(this.random() * 3),
                    10 + Math.floor(this.random() * 5), 15, "#4CAF50", false);
            }
            static createGoblin() {
                return new Enemy("Goblin", 8 + Math.floor(this.random() * 15), 3 + Math.floor(this.random() * 6),
                    10 + Math.floor(this.random() * 20), 30, "#FF9800", false);
            }
            static createSkeleton() {
                return new Enemy("Skeleton", 12 + Math.floor(this.random() * 50), 5 + Math.floor(this.random() * 7),
                    20 + Math.floor(this.random() * 30), 40, "#FFFFFF", false);
            }
            static createOrc() {
                return new Enemy("Orc", 50 + Math.floor(this.random() * 50), 10 + Math.floor(this.random() * 8),
                    20 + Math.floor(this.random() * 100), 60, "#558B2F", false);
            }
            static createFireElemental() {
                const e = new Enemy("Fire Elemental", 100 + Math.floor(this.random() * 100), 18 + Math.floor(this.random() * 8),
                    50 + Math.floor(this.random() * 150), 90, "#F44336", false, true, false, true);
                e.element = "Fire";
                return e;
            }
            static createWaterElemental() {
                const e = new Enemy("Water Elemental", 100 + Math.floor(this.random() * 100), 18 + Math.floor(this.random() * 8),
                    50 + Math.floor(this.random() * 150), 90, "#2196F3", false, true, false, true);
                e.element = "Water";
                return e;
            }
            static createGrassElemental() {
                const e = new Enemy("Grass Elemental", 100 + Math.floor(this.random() * 100), 18 + Math.floor(this.random() * 8),
                    50 + Math.floor(this.random() * 150), 90, "#4CAF50", false, true, false, true);
                e.element = "Grass";
                return e;
            }
            static createGiantSlime() {
                return new Enemy("Giant Slime", 60 + Math.floor(this.random() * 10), 1 + Math.floor(this.random() * 10),
                    500, 300, "#BA68C8", true, true, true, true);
            }
            static createGoblinWarlord() {
                return new Enemy("Goblin Warlord", 100 + Math.floor(this.random() * 10), 2 + Math.floor(this.random() * 50),
                    500, 300, "#607D8B", true, true, true, true);
            }
            static createFireDragon() {
                const e = new Enemy("Fire Dragon", 50 + Math.floor(this.random() * 550), 10 + Math.floor(this.random() * 100),
                    500, 300, "#F44336", true, true, true, true);
                e.element = "Fire";
                return e;
            }
            static createIceGolem() {
                const e = new Enemy("Ice Golem", 50 + Math.floor(this.random() * 1000), 5 + Math.floor(this.random() * 80),
                    500, 300, "#00BCD4", true, true, true, true);
                e.element = "Water";
                return e;
            }
            static createShadowLord() {
                return new Enemy("Shadow Lord", 50 + Math.floor(this.random() * 500), 5 + Math.floor(this.random() * 150),
                    500, 300, "#311B92", true, true, true, true);
            }
            static createMossBeast() {
                const e = new Enemy("Mossy Beast", 50 + Math.floor(this.random() * 600), 10 + Math.floor(this.random() * 100),
                    500, 300, "#388E3C", true, true, true, true);
                e.element = "Grass";
                return e;
            }
            static createSlayActEnemy(act) {
                let e;
                const roll = Math.floor(this.random() * 100);
                if (act === 1) {
                    e = roll < 60 ? this.createSlime() : this.createGoblin();
                } else if (act === 2) {
                    e = roll < 50 ? this.createGoblin() : this.createSkeleton();
                } else if (act === 3) {
                    e = roll < 50 ? this.createSkeleton() : this.createOrc();
                } else if (act === 4) {
                    if (roll < 40) e = this.createOrc();
                    else if (roll < 60) e = this.createFireElemental();
                    else if (roll < 80) e = this.createGrassElemental();
                    else e = this.createWaterElemental();
                } else {
                    if (roll < 33) e = this.createFireElemental();
                    else if (roll < 66) e = this.createWaterElemental();
                    else e = this.createGrassElemental();
                }
                e.expReward *= 10;
                e.goldReward *= 10;
                e.name = "Dungeon " + e.name;
                return e;
            }
            static createSlayActBoss(act) {
                switch (act) {
                    case 1: return this.createGiantSlime();
                    case 2: return this.createGoblinWarlord();
                    default:
                        const roll = Math.floor(this.random() * 100);
                        if (roll < 30) return this.createShadowLord();
                        if (roll < 60) return this.createMossBeast();
                        if (roll < 80) return this.createFireDragon();
                        return this.createIceGolem();
                }
            }
            static createRandomEnemy(playerLevel) {
                const roll = Math.floor(this.random() * 100);
                if (playerLevel <= 6) {
                    return roll < 90 ? this.createSlime() : this.createGoblin();
                } else if (playerLevel <= 7) {
                    if (roll < 30) return this.createSlime();
                    if (roll < 60) return this.createGoblin();
                    return this.createSkeleton();
                } else if (playerLevel <= 8) {
                    if (roll < 15) return this.createGoblin();
                    if (roll < 30) return this.createSlime();
                    if (roll < 50) return this.createSkeleton();
                    return this.createOrc();
                } else {
                    if (roll < 10) return this.createSkeleton();
                    if (roll < 20) return this.createSlime();
                    if (roll < 30) return this.createGoblin();
                    if (roll < 60) return this.createOrc();
                    if (roll < 75) return this.createFireElemental();
                    if (roll < 90) return this.createGrassElemental();
                    return this.createWaterElemental();
                }
            }
            static createRandomBoss() {
                const roll = Math.floor(this.random() * 100);
                if (roll < 30) return this.createGiantSlime();
                if (roll < 50) return this.createGoblinWarlord();
                if (roll < 60) return this.createShadowLord();
                if (roll < 75) return this.createMossBeast();
                if (roll < 90) return this.createFireDragon();
                return this.createIceGolem();
            }
        }
        // ==================== ITEM ====================
        class Item {
            static nextId = 0;
            constructor(name, cost, consumable, equippable, healAmount, attackBonus, hpBonus, type, element) {
                this.name = name;
                this.cost = cost;
                this.consumable = consumable;
                this.equippable = equippable;
                this.healAmount = healAmount;
                this.attackBonus = attackBonus;
                this.hpBonus = hpBonus;
                this.type = type;
                this.element = element;
                this.uniqueId = Item.nextId++;
            }
            isSpell() {
                return this.type === "Spell";
            }
            isWeapon() {
                return this.type === "Weapon";
            }
            isArmor() {
                return this.type === "Armor";
            }
            toString() {
                let sb = this.name;
                if (this.equippable) {
                    if (this.attackBonus !== 0) sb += ` (ATK+${this.attackBonus})`;
                    if (this.hpBonus !== 0) sb += ` (HP+${this.hpBonus})`;
                } else if (this.consumable) {
                    if (this.attackBonus !== 0) {
                        sb += ` (ATK ${this.attackBonus})`;
                    } else {
                        sb += ` (Heal ${this.healAmount})`;
                    }
                }
                sb += ` - ${this.cost}g`;
                return sb;
            }
            save() {
                return {
                    name: this.name,
                    cost: this.cost,
                    consumable: this.consumable,
                    equippable: this.equippable,
                    healAmount: this.healAmount,
                    attackBonus: this.attackBonus,
                    hpBonus: this.hpBonus,
                    type: this.type,
                    element: this.element,
                    uniqueId: this.uniqueId
                };
            }
            static load(data) {
                const item = new Item(
                    data.name,
                    data.cost,
                    data.consumable,
                    data.equippable,
                    data.healAmount,
                    data.attackBonus,
                    data.hpBonus,
                    data.type,
                    data.element
                );
                item.uniqueId = data.uniqueId;
                if (item.uniqueId >= Item.nextId) {
                    Item.nextId = item.uniqueId + 1;
                }
                return item;
            }
        }
        // ==================== OVERWORLD ====================
        class Overworld {
            constructor(game) {
                this.game = game;
                this.canvas = document.getElementById('overworld-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.TILE_SIZE = 40;
                this.MAP_WIDTH = 64;
                this.MAP_HEIGHT = 44;
                this.VIEW_WIDTH = 16;
                this.VIEW_HEIGHT = 12;
                this.camRow = 0;
                this.camCol = 0;
                this.playerX = 2;
                this.playerY = 2;
                this.stepCounter = 0;
                this.pendingAction = null;
                this.map = this.createMap();
            }
            createMap() {
                // Simplified map array - in a real game you'd have the full 64x44 array
                const map = Array(this.MAP_HEIGHT).fill().map(() => Array(this.MAP_WIDTH).fill(1));
                // Create paths
                for (let y = 1; y < this.MAP_HEIGHT - 1; y++) {
                    for (let x = 1; x < this.MAP_WIDTH - 1; x++) {
                        if ((x > 1 && x < this.MAP_WIDTH - 2 && y === 2) ||
                            (y > 1 && y < this.MAP_HEIGHT - 2 && x === 2) ||
                            (x > 10 && x < 20 && y > 5 && y < 15)) {
                            map[y][x] = 0;
                        }
                    }
                }
                // Place NPCs
                map[5][10] = 2;  // Regular NPC
                map[8][15] = 3;  // Shop
                map[12][8] = 5;  // Dungeon
                map[15][20] = 10; // Slime quest
                return map;
            }
            onShow() {
                this.updateCamera();
                this.render();
            }
            updateCamera() {
                this.camRow = this.playerY - Math.floor(this.VIEW_HEIGHT / 2);
                this.camCol = this.playerX - Math.floor(this.VIEW_WIDTH / 2);
                if (this.camRow < 0) this.camRow = 0;
                if (this.camCol < 0) this.camCol = 0;
                if (this.camRow > this.MAP_HEIGHT - this.VIEW_HEIGHT) this.camRow = this.MAP_HEIGHT - this.VIEW_HEIGHT;
                if (this.camCol > this.MAP_WIDTH - this.VIEW_WIDTH) this.camCol = this.MAP_WIDTH - this.VIEW_WIDTH;
            }
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // Draw map
                for (let r = 0; r < this.VIEW_HEIGHT; r++) {
                    for (let c = 0; c < this.VIEW_WIDTH; c++) {
                        const mapY = this.camRow + r;
                        const mapX = this.camCol + c;
                        if (mapY < 0 || mapY >= this.MAP_HEIGHT || mapX < 0 || mapX >= this.MAP_WIDTH) continue;
                        const tile = this.map[mapY][mapX];
                        const x = c * this.TILE_SIZE;
                        const y = r * this.TILE_SIZE;
                        switch (tile) {
                            case 0: this.ctx.fillStyle = '#32CD32'; break; // grass
                            case 1: this.ctx.fillStyle = '#78460F'; break; // wall
                            case 2: this.ctx.fillStyle = '#0000FF'; break; // NPC
                            case 3: this.ctx.fillStyle = '#B478FF'; break; // shop
                            case 5: this.ctx.fillStyle = '#FFDC64'; break; // dungeon
                            case 10: this.ctx.fillStyle = '#64FF64'; break; // quest
                            default: this.ctx.fillStyle = '#FF69B4'; break; // fallback
                        }
                        this.ctx.fillRect(x, y, this.TILE_SIZE, this.TILE_SIZE);
                    }
                }
                // Draw player
                const px = (this.playerX - this.camCol) * this.TILE_SIZE;
                const py = (this.playerY - this.camRow) * this.TILE_SIZE;
                this.ctx.fillStyle = '#FF0000';
                this.ctx.fillRect(px, py, this.TILE_SIZE, this.TILE_SIZE);
                // Draw HUD text
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '14px Courier New';
                this.ctx.fillText(
                    `Gold: ${this.game.player.gold} HP: ${this.game.player.currentHP}/${this.game.player.getMaxHP()} ` +
                    `ATK: ${this.game.player.getAttack()} LV: ${this.game.player.level} ` +
                    `EXP: ${this.game.player.exp}/${this.game.player.level * 60} ` +
                    `Bosses: ${this.game.getDefeatedBossCount()}/5`,
                    10, 25
                );
            }
            handleKeyDown(e) {
                const keyMap = {
                    'ArrowUp': [0, -1], 'w': [0, -1], 'W': [0, -1],
                    'ArrowDown': [0, 1], 's': [0, 1], 'S': [0, 1],
                    'ArrowLeft': [-1, 0], 'a': [-1, 0], 'A': [-1, 0],
                    'ArrowRight': [1, 0], 'd': [1, 0], 'D': [1, 0],
                    ' ': this.handleSpace.bind(this),
                    'i': () => this.game.showScreen('inventory'),
                    'I': () => this.game.showScreen('inventory')
                };
                if (keyMap[e.key]) {
                    if (typeof keyMap[e.key] === 'function') {
                        keyMap[e.key]();
                    } else {
                        this.movePlayer(...keyMap[e.key]);
                    }
                }
            }
            handleSpace() {
                if (this.game.dialogueBox.classList.contains('active')) {
                    if (this.pendingAction) {
                        this.handlePendingAction();
                    } else {
                        this.game.hideDialogue();
                    }
                } else {
                    this.talkToNPC();
                }
            }
            handlePendingAction() {
                const action = this.pendingAction;
                this.pendingAction = null;
                this.game.hideDialogue();
                if (action.startsWith('ACCEPT_QUEST_')) {
                    const tileType = parseInt(action.replace('ACCEPT_QUEST_', ''));
                    this.acceptQuest(tileType);
                } else if (action === 'ACCEPT_GOLD_QUEST') {
                    this.acceptGoldQuest();
                } else if (action === 'DONATE_GOLD') {
                    this.donateGold();
                } else if (action === 'SHOP') {
                    this.game.returnScreen = 'overworld';
                    this.game.showScreen('shop');
                } else if (action === 'DUNGEON') {
                    this.game.showScreen('dungeon');
                }
            }
            movePlayer(dx, dy) {
                if (this.game.dialogueBox.classList.contains('active')) return;
                const newX = this.playerX + dx;
                const newY = this.playerY + dy;
                if (newX < 0 || newX >= this.MAP_WIDTH || newY < 0 || newY >= this.MAP_HEIGHT) {
                    console.log('[DEBUG] Move blocked: out of bounds');
                    return;
                }
                if (this.map[newY][newX] !== 1) {
                    this.playerX = newX;
                    this.playerY = newY;
                    this.stepCounter++;
                    console.log(`[DEBUG] Moved to (${this.playerX},${this.playerY}) steps=${this.stepCounter}`);
                    // Random encounter
                    if (Math.random() < 0.1 && this.map[this.playerY][this.playerX] === 0) {
                        console.log('[DEBUG] Random encounter triggered!');
                        this.game.returnScreen = 'overworld';
                        this.game.showScreen('battle');
                        return;
                    }
                    this.updateCamera();
                    this.render();
                } else {
                    console.log(`[DEBUG] Move blocked by wall at (${newX},${newY})`);
                }
            }
            talkToNPC() {
                const deltas = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                for (const [dx, dy] of deltas) {
                    const nx = this.playerX + dx;
                    const ny = this.playerY + dy;
                    if (nx < 0 || nx >= this.MAP_WIDTH || ny < 0 || ny >= this.MAP_HEIGHT) continue;
                    const tile = this.map[ny][nx];
                    if (tile === 2) {
                        this.game.showDialogue("Hello traveler! Beware the monsters!");
                        return;
                    } else if (tile === 3) {
                        this.game.showDialogue("Welcome to my shop! Press SPACE to go trade.", "SHOP");
                        return;
                    } else if (tile === 5) {
                        if (this.game.player.level <= 6) {
                            this.game.showDialogue("Switch Master: You're too weak for my dungeon! Come back when you're stronger (Level 7+).");
                        } else {
                            this.game.lastNpcX = nx;
                            this.game.lastNpcY = ny;
                            this.game.showDialogue("Switch Master: Do you dare test Your Knowlage? Press SPACE to enter.", "DUNGEON");
                        }
                        return;
                    } else if (tile >= 10 && tile <= 16) {
                        this.handleQuestNPC(tile, nx, ny);
                        return;
                    }
                }
                this.game.showDialogue("There's no one nearby to talk to.");
            }
            handleQuestNPC(tileType, x, y) {
                let monsterType = "";
                let goldReward = 0;
                switch (tileType) {
                    case 10: monsterType = "Slime"; goldReward = 50; break;
                    case 11: monsterType = "Goblin"; goldReward = 100; break;
                    case 12: monsterType = "Skeleton"; goldReward = 200; break;
                    case 13: monsterType = "Orc"; goldReward = 300; break;
                    case 14: monsterType = "Fire Elemental"; goldReward = 500; break;
                    case 15: monsterType = "Water Elemental"; goldReward = 500; break;
                    case 16: monsterType = "Grass Elemental"; goldReward = 500; break;
                }
                const questName = monsterType + " Slayer";
                const existingQuest = this.game.player.activeQuests.find(q => q.name === questName);
                if (existingQuest) {
                    if (existingQuest.completed && !existingQuest.turnedIn) {
                        this.game.player.completeQuest(existingQuest);
                        this.game.showDialogue(`Thank you for defeating those ${monsterType}s!
You earned ${goldReward} gold and ${existingQuest.expReward} EXP!`);
                    } else if (existingQuest.turnedIn) {
                        this.game.showDialogue(`Thanks again for your help with the ${monsterType} problem!`);
                    } else {
                        this.game.showDialogue(`How's the quest going?
Progress: ${existingQuest.getProgress()}`);
                    }
                } else {
                    const expReward = goldReward;
                    this.game.showDialogue(`${monsterType}s are rampaging! Please defeat 5 ${monsterType}s for ${goldReward} gold and ${expReward} EXP?
Press SPACE to accept.`, `ACCEPT_QUEST_${tileType}`);
                }
            }
            acceptQuest(tileType) {
                let monsterType = "";
                let goldReward = 0;
                let expReward = 0;
                switch (tileType) {
                    case 10: monsterType = "Slime"; goldReward = 50; expReward = 50; break;
                    case 11: monsterType = "Goblin"; goldReward = 100; expReward = 100; break;
                    case 12: monsterType = "Skeleton"; goldReward = 200; expReward = 200; break;
                    case 13: monsterType = "Orc"; goldReward = 300; expReward = 300; break;
                    case 14: monsterType = "Fire Elemental"; goldReward = 500; expReward = 500; break;
                    case 15: monsterType = "Water Elemental"; goldReward = 500; expReward = 500; break;
                    case 16: monsterType = "Grass Elemental"; goldReward = 500; expReward = 500; break;
                }
                const newQuest = new Quest(
                    monsterType + " Slayer",
                    "Defeat 5 " + monsterType + "s",
                    monsterType,
                    5,
                    goldReward,
                    expReward,
                    "KILL"
                );
                this.game.player.addQuest(newQuest);
                this.game.showDialogue(`Quest accepted! ${newQuest.description}
Return here when you've completed it.`);
                this.game.updateQuestPanel();
            }
            resetPlayerPosition() {
                this.playerX = 2;
                this.playerY = 2;
            }
            save() {
                return {
                    playerX: this.playerX,
                    playerY: this.playerY,
                    camRow: this.camRow,
                    camCol: this.camCol
                };
            }
            load(data) {
                this.playerX = data.playerX || 2;
                this.playerY = data.playerY || 2;
                this.camRow = data.camRow || 0;
                this.camCol = data.camCol || 0;
            }
        }
        // ==================== BATTLE ====================
        class Battle {
            constructor(game) {
                this.game = game;
                this.currentEnemy = null;
                this.isBoss = false;
                this.waitingForPlayer = false;
                this.showingMessage = false;
                this.message = "";
                this.inBattle = false;
                this.selectedAction = 0;
                this.selectingSpell = false;
                this.selectedSpell = 0;
                this.selectingPotion = false;
                this.selectedPotion = 0;
                this.selectingBomb = false;
                this.selectedBomb = 0;
                this.playerJustAttacked = false;
                this.enemyCharging = false;
                this.enemyEnraged = false;
            }
            startBattle() {
                // Simplified - in real game check if boss is pending
                this.isBoss = false;
                if (this.game.returnScreen === 'slay-map') {
                    const act = this.game.slayMap.getActNumber();
                    this.currentEnemy = EnemyFactory.createSlayActEnemy(act);
                } else {
                    this.currentEnemy = EnemyFactory.createRandomEnemy(this.game.player.level);
                }
                this.playerEnterBattlePrep();
            }
            playerEnterBattlePrep() {
                this.selectedAction = 0;
                this.inBattle = true;
                this.waitingForPlayer = false;
                this.showingMessage = true;
                this.message = this.isBoss ?
                    `A powerful ${this.currentEnemy.name} blocks your path!` :
                    `A wild ${this.currentEnemy.name} appeared!`;
                this.enemyCharging = false;
                this.enemyEnraged = false;
                this.playerJustAttacked = false;
                if (this.game.player.currentHP > this.game.player.getMaxHP()) {
                    this.game.player.currentHP = this.game.player.getMaxHP();
                }
                this.updateUI();
            }
            updateUI() {
                // Update enemy display
                const enemyDisplay = document.getElementById('enemy-display');
                enemyDisplay.style.background = this.currentEnemy.color;
                enemyDisplay.textContent = '';
                document.getElementById('enemy-name').textContent = this.currentEnemy.name;
                document.getElementById('enemy-hp').textContent =
                    `HP: ${Math.max(0, this.currentEnemy.currentHP)}/${this.currentEnemy.maxHP}`;
                // Update player stats
                document.getElementById('player-hp').textContent = this.game.player.currentHP;
                document.getElementById('player-maxhp').textContent = this.game.player.getMaxHP();
                document.getElementById('player-lv').textContent = this.game.player.level;
                document.getElementById('player-atk').textContent = this.game.player.getAttack();
                document.getElementById('player-exp').textContent = this.game.player.exp;
                document.getElementById('player-exp-max').textContent = this.game.player.level * 60;
                document.getElementById('player-gold').textContent = this.game.player.gold;
                // Update battle menu selection
                document.querySelectorAll('#battle-menu .menu-item').forEach((item, index) => {
                    item.classList.toggle('selected', index === this.selectedAction);
                });
                // Show/hide message
                const messageEl = document.getElementById('battle-message');
                const messageText = document.getElementById('battle-message-text');
                if (this.showingMessage && this.message) {
                    messageText.textContent = this.message;
                    messageEl.style.display = 'block';
                } else {
                    messageEl.style.display = 'none';
                }
            }
            handleKeyDown(e) {
                if (this.showingMessage) {
                    if (e.key === ' ' || e.key === 'Enter') {
                        this.handleContinue();
                    }
                    return;
                }
                if (!this.waitingForPlayer) return;
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                    if (this.selectingSpell) {
                        this.selectedSpell = (this.selectedSpell - 1 + this.game.player.equippedSpells.length) % this.game.player.equippedSpells.length;
                    } else if (this.selectingPotion) {
                        this.selectedPotion = (this.selectedPotion - 1 + this.game.player.equippedPotions.length) % this.game.player.equippedPotions.length;
                    } else if (this.selectingBomb) {
                        this.selectedBomb = (this.selectedBomb - 1 + this.game.player.equippedBombs.length) % this.game.player.equippedBombs.length;
                    } else {
                        this.selectedAction = (this.selectedAction - 1 + 5) % 5;
                    }
                    this.updateUI();
                } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                    if (this.selectingSpell) {
                        this.selectedSpell = (this.selectedSpell + 1) % this.game.player.equippedSpells.length;
                    } else if (this.selectingPotion) {
                        this.selectedPotion = (this.selectedPotion + 1) % this.game.player.equippedPotions.length;
                    } else if (this.selectingBomb) {
                        this.selectedBomb = (this.selectedBomb + 1) % this.game.player.equippedBombs.length;
                    } else {
                        this.selectedAction = (this.selectedAction + 1) % 5;
                    }
                    this.updateUI();
                } else if (e.key === 'Enter' || e.key === ' ') {
                    if (this.selectingSpell) {
                        this.castSelectedSpell();
                    } else if (this.selectingPotion) {
                        this.useSelectedPotion();
                    } else if (this.selectingBomb) {
                        this.useSelectedBomb();
                    } else {
                        this.performSelectedAction();
                    }
                } else if (e.key === 'x' || e.key === 'X') {
                    if (this.selectingSpell || this.selectingPotion || this.selectingBomb) {
                        this.selectingSpell = false;
                        this.selectingPotion = false;
                        this.selectingBomb = false;
                        this.selectedSpell = 0;
                        this.selectedPotion = 0;
                        this.selectedBomb = 0;
                        this.waitingForPlayer = true;
                        this.updateUI();
                    }
                }
            }
            selectAction(action) {
                const actions = ['attack', 'magic', 'potion', 'bomb', 'run'];
                this.selectedAction = actions.indexOf(action);
                this.performSelectedAction();
            }
            performSelectedAction() {
                const actions = ['attack', 'magic', 'potion', 'bomb', 'run'];
                const action = actions[this.selectedAction];
                console.log(`[DEBUG] Player selected: ${action}`);
                switch (action) {
                    case 'attack':
                        this.game.playSound('attack');
                        const dmg = this.game.player.getAttack() + Math.floor(Math.random() * 3);
                        this.currentEnemy.currentHP -= dmg;
                        this.message = `You attack and deal ${dmg} damage!`;
                        this.playerJustAttacked = true;
                        this.showingMessage = true;
                        this.waitingForPlayer = false;
                        if (this.currentEnemy.currentHP <= 0) {
                            this.handleVictory();
                        }
                        break;
                    case 'run':
                        this.attemptRun();
                        return;
                    case 'potion':
                        if (this.game.player.equippedPotions.length === 0) {
                            this.message = "No potions equipped!";
                            this.showingMessage = true;
                            this.waitingForPlayer = false;
                        } else {
                            this.selectingPotion = true;
                            this.selectedPotion = 0;
                            this.waitingForPlayer = false;
                        }
                        break;
                    case 'bomb':
                        if (this.game.player.equippedBombs.length === 0) {
                            this.message = "No bombs equipped!";
                            this.showingMessage = true;
                            this.waitingForPlayer = false;
                        } else {
                            this.selectingBomb = true;
                            this.selectedBomb = 0;
                            this.waitingForPlayer = false;
                        }
                        break;
                    case 'magic':
                        if (this.game.player.equippedSpells.length === 0) {
                            this.message = "No spells equipped!";
                            this.showingMessage = true;
                            this.waitingForPlayer = false;
                        } else {
                            this.selectingSpell = true;
                            this.selectedSpell = 0;
                            this.waitingForPlayer = false;
                        }
                        break;
                }
                this.updateUI();
            }
            useSelectedPotion() {
                if (this.game.player.equippedPotions.length === 0) return;
                const potion = this.game.player.equippedPotions[this.selectedPotion];
                this.game.playSound('potion');
                const oldHP = this.game.player.currentHP;
                this.game.player.currentHP += potion.healAmount;
                if (this.game.player.currentHP > this.game.player.getMaxHP()) {
                    this.game.player.currentHP = this.game.player.getMaxHP();
                }
                const actualHealed = this.game.player.currentHP - oldHP;
                this.message = `You used ${potion.name} and healed ${actualHealed} HP!`;
                // Remove from inventory and equipped
                this.game.player.inventory = this.game.player.inventory.filter(i => i.uniqueId !== potion.uniqueId);
                this.game.player.equippedPotions = this.game.player.equippedPotions.filter(p => p.uniqueId !== potion.uniqueId);
                this.playerJustAttacked = false;
                this.showingMessage = true;
                this.selectingPotion = false;
                this.selectedPotion = 0;
                this.updateUI();
            }
            castSelectedSpell() {
                if (this.game.player.equippedSpells.length === 0) return;
                const spell = this.game.player.equippedSpells[this.selectedSpell];
                this.game.playSound('magic');
                this.game.shake(200, 8);
                let damageMultiplier = 1.0;
                let messageSuffix = "";
                if (spell.element && this.currentEnemy.element) {
                    if ((spell.element === "Fire" && this.currentEnemy.element === "Grass") ||
                        (spell.element === "Grass" && this.currentEnemy.element === "Water") ||
                        (spell.element === "Water" && this.currentEnemy.element === "Fire")) {
                        damageMultiplier = 2.0;
                        messageSuffix = " It's super effective!";
                    }
                }
                const baseDmg = 15 + Math.floor(Math.random() * 100);
                const dmg = Math.floor(baseDmg * damageMultiplier);
                this.currentEnemy.currentHP -= dmg;
                this.message = `You cast ${spell.name} for ${dmg} damage!${messageSuffix}`;
                this.playerJustAttacked = true;
                this.showingMessage = true;
                this.selectingSpell = false;
                this.selectedSpell = 0;
                if (this.currentEnemy.currentHP <= 0) {
                    this.handleVictory();
                }
                this.updateUI();
            }
            useSelectedBomb() {
                if (this.game.player.equippedBombs.length === 0) return;
                const bomb = this.game.player.equippedBombs[this.selectedBomb];
                this.game.playSound('bomb');
                this.game.shake(200, 8);
                const levelScaling = this.game.player.level;
                const dmg = bomb.attackBonus + Math.floor(Math.random() * bomb.attackBonus) + levelScaling;
                this.currentEnemy.currentHP -= dmg;
                this.message = `Threw a ${bomb.name} for ${dmg} damage!`;
                // Remove from inventory and equipped
                this.game.player.inventory = this.game.player.inventory.filter(i => i.uniqueId !== bomb.uniqueId);
                this.game.player.equippedBombs = this.game.player.equippedBombs.filter(b => b.uniqueId !== bomb.uniqueId);
                this.playerJustAttacked = true;
                this.showingMessage = true;
                this.selectingBomb = false;
                this.selectedBomb = 0;
                if (this.currentEnemy.currentHP <= 0) {
                    this.handleVictory();
                }
                this.updateUI();
            }
            handleVictory() {
                this.game.playSound('victory');
                this.inBattle = false;
                this.game.player.trackMonsterKill(this.currentEnemy.name);
                const victoryText = `${this.currentEnemy.name} defeated!
You found ${this.currentEnemy.goldReward} gold and gained ${this.currentEnemy.expReward} EXP!`;
                if (this.message) {
                    this.message += "" + victoryText;
                } else {
                    this.message = victoryText;
                }
                this.game.player.gold += this.currentEnemy.goldReward;
                this.game.player.gainExp(this.currentEnemy.expReward);
                this.playerJustAttacked = false;
            }
            attemptRun() {
                if (this.currentEnemy.isBoss) {
                    this.game.playSound('mustfight');
                    this.message = "You can't escape from this battle!";
                    this.showingMessage = true;
                    this.waitingForPlayer = false;
                    this.playerJustAttacked = false;
                    console.log('[DEBUG] Escape attempt blocked (boss battle)');
                    this.updateUI();
                } else {
                    const success = Math.random() < 0.5;
                    if (success) {
                        this.game.playSound('esc');
                        this.message = "You successfully ran away!";
                        this.showingMessage = true;
                        this.waitingForPlayer = false;
                        this.inBattle = false;
                        console.log('[DEBUG] Player escaped from battle');
                    } else {
                        this.game.playSound('mustfight');
                        this.message = "You failed to escape!";
                        this.showingMessage = true;
                        this.waitingForPlayer = false;
                        this.playerJustAttacked = true;
                        console.log('[DEBUG] Run failed');
                    }
                    this.updateUI();
                }
            }
            handleContinue() {
                // Victory logic
                if (!this.inBattle && this.currentEnemy.currentHP <= 0) {
                    console.log('[DEBUG] Battle won.');
                    if (this.game.returnScreen === 'overworld') {
                        if (this.currentEnemy.isBoss) {
                            const npcTileType = 5; // Simplified
                            if (npcTileType >= 5 && npcTileType <= 9) {
                                this.game.addDefeatedBoss(npcTileType);
                            }
                            if (this.game.getDefeatedBossCount() >= 5) {
                                this.game.showScreen('game-beat');
                            } else {
                                this.game.showScreen('victory');
                            }
                        } else {
                            this.game.showScreen('overworld');
                        }
                    } else if (this.game.returnScreen === 'slay-map') {
                        if (this.currentEnemy.isBoss) {
                            if (this.game.slayMap.getActNumber() >= 10) {
                                this.game.showScreen('game-beat');
                            } else {
                                this.game.showScreen('slay-act-clear');
                            }
                        } else {
                            this.game.showScreen('slay-map');
                        }
                    }
                    return;
                }
                // Run away logic
                if (!this.inBattle && this.message.includes('ran away')) {
                    this.game.showScreen(this.game.returnScreen);
                    return;
                }
                // Player defeat logic
                if (!this.inBattle && this.game.player.currentHP <= 0) {
                    this.game.playSound('defeat');
                    console.log('[DEBUG] Player defeated. Returning to Menu.');
                    this.game.resetGame();
                    this.game.showScreen('menu');
                    return;
                }
                // Enemy turn
                if (this.showingMessage && this.inBattle && this.currentEnemy.currentHP > 0 && this.playerJustAttacked) {
                    if (this.waitingForPlayer) {
                        this.showingMessage = false;
                        this.message = "";
                        return;
                    }
                    this.playerJustAttacked = false;
                    this.performEnemyAction();
                    if (this.game.player.currentHP <= 0) {
                        this.game.playSound('defeat');
                        this.game.resetGame();
                        this.game.showScreen('menu');
                    }
                    this.updateUI();
                    return;
                }
                // Default continue
                this.showingMessage = false;
                this.waitingForPlayer = true;
                this.message = "";
                this.updateUI();
            }
            performEnemyAction() {
                if (this.enemyCharging) {
                    this.game.shake(300, 10);
                    const dmg = this.currentEnemy.getAttackDamage(Math.random, this.enemyEnraged, true, this.game.player.level);
                    this.game.player.currentHP -= dmg;
                    this.message = `The ${this.currentEnemy.name} unleashes a devastating blow for ${dmg}!`;
                    this.enemyCharging = false;
                } else if (this.currentEnemy.canHeal && this.currentEnemy.currentHP < this.currentEnemy.healThreshold && Math.random() < 0.25) {
                    const heal = 1 + Math.floor(Math.random() * 50);
                    this.currentEnemy.currentHP = Math.min(this.currentEnemy.currentHP + heal, this.currentEnemy.maxHP);
                    this.message = `The ${this.currentEnemy.name} heals itself for ${heal}!`;
                } else if (this.currentEnemy.canCharge && Math.random() < 0.2) {
                    this.enemyCharging = true;
                    this.message = `The ${this.currentEnemy.name} begins charging!`;
                } else if (this.currentEnemy.canEnrage && this.currentEnemy.currentHP < this.currentEnemy.enrageThreshold && !this.enemyEnraged) {
                    this.enemyEnraged = true;
                    this.game.shake(250, 7);
                    const dmg = this.currentEnemy.getAttackDamage(Math.random, this.enemyEnraged, false, this.game.player.level);
                    this.game.player.currentHP -= dmg;
                    this.message = `The ${this.currentEnemy.name} goes berserk! and attacks for ${dmg} damage!`;
                } else {
                    if (this.currentEnemy.isBoss) {
                        this.game.shake(250, 7);
                    }
                    const dmg = this.currentEnemy.getAttackDamage(Math.random, this.enemyEnraged, false, this.game.player.level);
                    this.game.player.currentHP -= dmg;
                    this.message = `The ${this.currentEnemy.name} attacks for ${dmg} damage!`;
                }
                this.showingMessage = true;
                this.waitingForPlayer = false;
            }
        }
        // ==================== INVENTORY ====================
        class Inventory {
            constructor(game) {
                this.game = game;
                this.selected = 0;
                this.message = "";
            }
            onShow() {
                this.render();
            }
            render() {
                const listEl = document.getElementById('inventory-list');
                const messageEl = document.getElementById('inventory-message');
                // Clear list
                listEl.innerHTML = '';
                // Add items
                this.game.player.inventory.forEach((item, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'item' + (index === this.selected ? ' selected' : '');
                    itemEl.dataset.index = index;
                    let itemText = item.name;
                    if (item.type === "Bomb") {
                        const scaledDmg = item.attackBonus + this.game.player.level;
                        itemText += ` (ATK ${scaledDmg})`;
                    } else {
                        itemText += item.equippable ?
                            (item.attackBonus ? ` (ATK+${item.attackBonus})` : ` (HP+${item.hpBonus})`) :
                            (item.healAmount ? ` (Heal ${item.healAmount})` : ` (ATK ${item.attackBonus})`);
                    }
                    itemText += ` - ${item.cost}g`;
                    // Add equipped indicator
                    if ((item.isWeapon() && this.game.player.equippedWeapon?.uniqueId === item.uniqueId) ||
                        (item.isArmor() && this.game.player.equippedArmor?.uniqueId === item.uniqueId) ||
                        (item.isSpell() && this.game.player.equippedSpells.some(s => s.uniqueId === item.uniqueId)) ||
                        (item.type === "Bomb" && this.game.player.equippedBombs.some(b => b.uniqueId === item.uniqueId)) ||
                        (item.consumable && this.game.player.equippedPotions.some(p => p.uniqueId === item.uniqueId))) {
                        itemText += " [E]";
                    }
                    itemEl.textContent = itemText;
                    listEl.appendChild(itemEl);
                });
                // Update equipped info
                document.getElementById('equipped-weapon').textContent =
                    this.game.player.equippedWeapon ? this.game.player.equippedWeapon.name : "None";
                document.getElementById('equipped-armor').textContent =
                    this.game.player.equippedArmor ? this.game.player.equippedArmor.name : "None";
                document.getElementById('spell-count').textContent = this.game.player.equippedSpells.length;
                document.getElementById('potion-count').textContent = this.game.player.equippedPotions.length;
                document.getElementById('bomb-count').textContent = this.game.player.equippedBombs.length;
                messageEl.textContent = this.message;
            }
            handleKeyDown(e) {
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                    if (this.game.player.inventory.length > 0) {
                        this.selected = (this.selected - 1 + this.game.player.inventory.length) % this.game.player.inventory.length;
                        this.render();
                    }
                } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                    if (this.game.player.inventory.length > 0) {
                        this.selected = (this.selected + 1) % this.game.player.inventory.length;
                        this.render();
                    }
                } else if (e.key === 'Enter') {
                    this.equipSelectedItem();
                } else if (e.key === 'u' || e.key === 'U') {
                    this.unequipSelectedItem();
                } else if (e.key === 'Escape') {
                    this.game.showScreen(this.game.lastScreen);
                }
            }
            selectItem(index) {
                this.selected = index;
                this.render();
                this.equipSelectedItem();
            }
            equipSelectedItem() {
                if (this.game.player.inventory.length === 0) return;
                const item = this.game.player.inventory[this.selected];
                if (item.isWeapon()) {
                    this.game.player.equip(item);
                    this.message = `Equipped ${item.name}`;
                } else if (item.isArmor()) {
                    this.game.player.equip(item);
                    this.message = `Equipped ${item.name}`;
                } else if (item.isSpell()) {
                    if (this.game.player.equippedSpells.some(s => s.uniqueId === item.uniqueId)) {
                        this.message = `${item.name} is already equipped!`;
                    } else if (this.game.player.equippedSpells.length >= 3) {
                        this.message = "Spell slots full! Press U to unequip.";
                    } else {
                        let duplicate = false;
                        if (item.element) {
                            for (const spell of this.game.player.equippedSpells) {
                                if (item.element === spell.element) {
                                    duplicate = true;
                                    break;
                                }
                            }
                        }
                        if (duplicate) {
                            this.message = `Cannot equip multiple ${item.element} spells!`;
                        } else {
                            this.game.player.equip(item);
                            this.message = `Equipped ${item.name}`;
                        }
                    }
                } else if (item.type === "Bomb") {
                    const already = this.game.player.equippedBombs.some(b => b.uniqueId === item.uniqueId);
                    if (already) {
                        this.message = "Already equipped!";
                    } else if (this.game.player.equippedBombs.length >= 4) {
                        this.message = "Bomb slots full!";
                    } else {
                        this.game.player.equip(item);
                        this.message = `Equipped ${item.name}`;
                    }
                } else if (item.consumable) {
                    const already = this.game.player.equippedPotions.some(p => p.uniqueId === item.uniqueId);
                    if (already) {
                        this.message = "Already equipped!";
                    } else if (this.game.player.equippedPotions.length >= 4) {
                        this.message = "Potion slots full!";
                    } else {
                        this.game.player.equip(item);
                        this.message = `Equipped ${item.name}`;
                    }
                } else {
                    this.message = `${item.name} cannot be equipped!`;
                }
                this.render();
            }
            unequipSelectedItem() {
                if (this.game.player.inventory.length === 0) return;
                const item = this.game.player.inventory[this.selected];
                if (item.isWeapon()) {
                    if (this.game.player.equippedWeapon?.uniqueId === item.uniqueId) {
                        this.game.player.unequipWeapon();
                        this.message = `Unequipped ${item.name}`;
                    } else {
                        this.message = "That weapon is not equipped!";
                    }
                } else if (item.isArmor()) {
                    if (this.game.player.equippedArmor?.uniqueId === item.uniqueId) {
                        this.game.player.unequipArmor();
                        this.message = `Unequipped ${item.name}`;
                    } else {
                        this.message = "That armor is not equipped!";
                    }
                } else if (item.isSpell() && this.game.player.equippedSpells.some(s => s.uniqueId === item.uniqueId)) {
                    this.game.player.unequipSpell(item);
                    this.message = `Unequipped ${item.name}`;
                } else if (item.consumable && this.game.player.equippedPotions.some(p => p.uniqueId === item.uniqueId)) {
                    this.game.player.unequipPotion(item);
                    this.message = `Unequipped ${item.name}`;
                } else if (item.type === "Bomb" && this.game.player.equippedBombs.some(b => b.uniqueId === item.uniqueId)) {
                    this.game.player.unequipBomb(item);
                    this.message = `Unequipped ${item.name}`;
                } else {
                    this.message = `${item.name} is not equipped!`;
                }
                this.render();
            }
        }
        // ==================== SHOP ====================
        class Shop {
            constructor(game) {
                this.game = game;
                this.shopItems = [];
                this.selected = 0;
                this.message = "";
                this.sellingMode = false;
                this.soldOutIndices = new Set();
                this.initItems();
            }
            initItems() {
                this.shopItems = [
                    new Item("Potion", 10, true, false, 15, 0, 0, "Potion", null),
                    new Item("Hi-Potion", 200, true, false, 50, 0, 0, "Potion", null),
                    new Item("Max-Potion", 500, true, false, 100, 0, 0, "Potion", null),
                    new Item("Bronze Sword", 300, false, true, 0, 5, 0, "Weapon", null),
                    new Item("Iron Sword", 800, false, true, 0, 10, 0, "Weapon", null),
                    new Item("Gold Sword", 1500, false, true, 0, 15, 0, "Weapon", null),
                    new Item("Diamond Sword", 2000, false, true, 0, 25, 0, "Weapon", null),
                    new Item("GrandMaster's Sword", 10000, false, true, 0, 100, 0, "Weapon", null),
                    new Item("Bronze Armor", 300, false, true, 0, 0, 10, "Armor", null),
                    new Item("Iron Armor", 800, false, true, 0, 0, 15, "Armor", null),
                    new Item("Gold Armor", 1500, false, true, 0, 0, 25, "Armor", null),
                    new Item("Diamond Armor", 2000, false, true, 0, 0, 100, "Armor", null),
                    new Item("GrandMaster's Armor", 10000, false, true, 0, 0, 500, "Armor", null),
                    new Item("Fire Spell", 1000, false, true, 0, 0, 0, "Spell", "Fire"),
                    new Item("Water Spell", 1000, false, true, 0, 0, 0, "Spell", "Water"),
                    new Item("Grass Spell", 1000, false, true, 0, 0, 0, "Spell", "Grass"),
                    new Item("Bomb", 50, true, false, 0, 12, 0, "Bomb", null)
                ];
            }
            onShow() {
                this.sellingMode = false;
                this.selected = 0;
                this.message = "Welcome! Use UP/DOWN to browse, ENTER to buy, Press T to sell, ESC to leave.";
                this.render();
            }
            render() {
                const listEl = document.getElementById('shop-list');
                const infoEl = document.getElementById('shop-info');
                const footerEl = document.getElementById('shop-footer');
                const goldEl = document.getElementById('shop-gold');
                const toggleBtn = document.getElementById('toggle-shop-mode');
                // Clear list
                listEl.innerHTML = '';
                // Update gold display
                goldEl.textContent = `Gold: ${this.game.player.gold}g`;
                // Update toggle button text
                toggleBtn.textContent = this.sellingMode ? "Switch to Buy Mode" : "Switch to Sell Mode";
                // Add items
                const items = this.sellingMode ? this.game.player.inventory : this.shopItems;
                items.forEach((item, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'item' + (index === this.selected ? ' selected' : '');
                    itemEl.dataset.index = index;
                    let itemText = "";
                    if (this.sellingMode) {
                        const sellPrice = Math.floor(item.cost / 2);
                        itemText = `${item.name} - Sell for ${sellPrice}g`;
                    } else {
                        if (item.type === "Bomb") {
                            const scaledDmg = item.attackBonus + this.game.player.level;
                            itemText = `${item.name} (ATK ${scaledDmg}) - ${item.cost}g`;
                        } else {
                            itemText = item.toString();
                        }
                        // Mark sold out spells
                        if (this.soldOutIndices.has(index)) {
                            itemText += " (SOLD OUT)";
                        }
                    }
                    itemEl.textContent = itemText;
                    listEl.appendChild(itemEl);
                });
                // Update info and footer
                infoEl.textContent = this.message;
                footerEl.textContent = this.sellingMode ?
                    "[UP/DOWN] Browse | [ENTER] Sell | [T] Buy Mode | [ESC] Back | [SPACE] Inspect | I: Inventory" :
                    "[UP/DOWN] Browse | [ENTER] Buy | [T] Sell Mode | [ESC] Back | [SPACE] Inspect | I: Inventory";
            }
            handleKeyDown(e) {
                const items = this.sellingMode ? this.game.player.inventory : this.shopItems;
                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                    if (items.length > 0) {
                        this.selected = (this.selected - 1 + items.length) % items.length;
                        this.render();
                    }
                } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                    if (items.length > 0) {
                        this.selected = (this.selected + 1) % items.length;
                        this.render();
                    }
                } else if (e.key === 'Enter') {
                    if (this.sellingMode) {
                        this.attemptSell();
                    } else {
                        this.attemptBuy();
                    }
                } else if (e.key === 't' || e.key === 'T') {
                    this.toggleMode();
                } else if (e.key === 'Escape') {
                    this.game.showScreen(this.game.returnScreen || 'overworld');
                } else if (e.key === ' ') {
                    const items = this.sellingMode ? this.game.player.inventory : this.shopItems;
                    if (items.length > 0) {
                        this.message = items[this.selected].toString();
                        this.render();
                    }
                } else if (e.key === 'i' || e.key === 'I') {
                    this.game.showScreen('inventory');
                }
            }
            selectItem(index) {
                this.selected = index;
                this.render();
                if (this.sellingMode) {
                    this.attemptSell();
                } else {
                    this.attemptBuy();
                }
            }
            toggleMode() {
                this.sellingMode = !this.sellingMode;
                this.selected = 0;
                this.message = this.sellingMode ? "Selling mode - Select item to sell" : "Buying mode - Select item to buy";
                this.render();
            }
            attemptBuy() {
                const item = this.shopItems[this.selected];
                if (this.soldOutIndices.has(this.selected)) {
                    this.message = "This item is sold out!";
                    this.render();
                    return;
                }
                if (this.game.player.gold >= item.cost) {
                    this.game.player.gold -= item.cost;
                    // Create new item instance
                    const newItem = new Item(
                        item.name, item.cost, item.consumable, item.equippable,
                        item.healAmount, item.attackBonus, item.hpBonus,
                        item.type, item.element
                    );
                    this.game.player.addItem(newItem);
                    // Mark spell as sold out
                    if (item.isSpell()) {
                        this.soldOutIndices.add(this.selected);
                    }
                    this.message = `Bought ${item.name}!`;
                    console.log(`[DEBUG] Player bought: ${item.name}`);
                } else {
                    this.message = "Not enough gold!";
                }
                this.render();
            }
            attemptSell() {
                if (this.game.player.inventory.length === 0) {
                    this.message = "You have nothing to sell!";
                    this.render();
                    return;
                }
                const item = this.game.player.inventory[this.selected];
                if (item.isSpell()) {
                    this.message = "You cannot sell spells!";
                    this.render();
                    return;
                }
                // Check if equipped
                let isEquipped = false;
                if (item === this.game.player.equippedWeapon || item === this.game.player.equippedArmor ||
                    this.game.player.equippedPotions.some(p => p.uniqueId === item.uniqueId) ||
                    this.game.player.equippedBombs.some(b => b.uniqueId === item.uniqueId)) {
                    isEquipped = true;
                }
                if (isEquipped) {
                    this.message = "Cannot sell equipped items! Unequip it first (Press I).";
                    this.render();
                    return;
                }
                // Process sale
                const sellPrice = Math.floor(item.cost / 2);
                this.game.player.removeItem(item);
                this.game.player.gold += sellPrice;
                this.message = `Sold ${item.name} for ${sellPrice}g!`;
                console.log(`[DEBUG] Player sold: ${item.name} for ${sellPrice}g`);
                // Adjust selection
                if (this.selected >= this.game.player.inventory.length && this.game.player.inventory.length > 0) {
                    this.selected = this.game.player.inventory.length - 1;
                } else if (this.game.player.inventory.length === 0) {
                    this.selected = 0;
                }
                this.render();
            }
            resetShop() {
                this.soldOutIndices.clear();
                this.selected = 0;
                this.sellingMode = false;
                this.message = "Welcome! Use UP/DOWN to browse, ENTER to buy, Press T to sell, ESC to leave.";
                this.render();
            }
        }
        // ==================== DUNGEON ====================
        class Dungeon {
            constructor(game) {
                this.game = game;
                this.canvas = document.getElementById('dungeon-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.TILE = 40;
                this.rows = 5;
                this.cols = 5;
                this.playerR = 1;
                this.playerC = 1;
                this.switchOn = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
                this.bossOpen = false;
                this.message = "";
            }
            onShow() {
                this.reset();
                this.message = "Dungeon: Step on the three switches to open the boss!";
                this.render();
            }
            reset() {
                this.switchOn = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
                this.bossOpen = false;
                this.playerR = 1;
                this.playerC = 1;
                this.message = "Dungeon reset.";
                this.render();
            }
            handleKeyDown(e) {
                const keyMap = {
                    'ArrowUp': [-1, 0], 'w': [-1, 0], 'W': [-1, 0],
                    'ArrowDown': [1, 0], 's': [1, 0], 'S': [1, 0],
                    'ArrowLeft': [0, -1], 'a': [0, -1], 'A': [0, -1],
                    'ArrowRight': [0, 1], 'd': [0, 1], 'D': [0, 1],
                    ' ': this.interact.bind(this),
                    'Escape': () => this.game.showScreen('overworld'),
                    'i': () => this.game.showScreen('inventory'),
                    'I': () => this.game.showScreen('inventory')
                };
                if (keyMap[e.key]) {
                    if (typeof keyMap[e.key] === 'function') {
                        keyMap[e.key]();
                    } else {
                        this.movePlayer(...keyMap[e.key]);
                    }
                }
            }
            movePlayer(dr, dc) {
                const nr = this.playerR + dr;
                const nc = this.playerC + dc;
                if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols) {
                    this.playerR = nr;
                    this.playerC = nc;
                    this.checkSwitch();
                    this.render();
                }
            }
            checkSwitch() {
                if ((this.playerR === 1 && this.playerC === 3) ||
                    (this.playerR === 2 && this.playerC === 2) ||
                    (this.playerR === 3 && this.playerC === 1)) {
                    this.switchOn[this.playerR][this.playerC] = !this.switchOn[this.playerR][this.playerC];
                    this.game.playSound('switch');
                    this.message = "You toggled a switch!";
                    const allOn = this.switchOn[1][3] && this.switchOn[2][2] && this.switchOn[3][1];
                    if (allOn) {
                        this.game.playSound('puzzlesolved');
                        this.bossOpen = true;
                        this.message = "A door opens in the north. The boss awaits!";
                    }
                }
            }
            interact() {
                console.log('[DEBUG] interact() called');
                if (this.bossOpen && this.playerR === 0 && this.playerC === 2) {
                    this.message = "The Guardian rages! Prepare to fight!";
                    this.render();
                    // Set boss pending and start battle
                    setTimeout(() => {
                        this.game.showScreen('battle');
                    }, 300);
                    return;
                }
                this.message = "Nothing to interact with here.";
                this.render();
            }
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const offsetY = 20;
                // Draw grid
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        const x = 50 + c * this.TILE;
                        const y = offsetY + r * this.TILE;
                        this.ctx.fillStyle = '#28283C';
                        this.ctx.fillRect(x, y, this.TILE - 2, this.TILE - 2);
                        // Draw switches
                        if ((r === 1 && c === 3) || (r === 2 && c === 2) || (r === 3 && c === 1)) {
                            this.ctx.fillStyle = this.switchOn[r][c] ? '#4CAF50' : '#F44336';
                            this.ctx.beginPath();
                            this.ctx.arc(x + this.TILE / 2, y + this.TILE / 2, this.TILE / 2 - 12, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        // Draw boss door
                        if (r === 0 && c === 2) {
                            this.ctx.fillStyle = this.bossOpen ? '#FF9800' : '#424242';
                            this.ctx.fillRect(x + 6, y + 6, this.TILE - 12, this.TILE - 12);
                            this.ctx.fillStyle = '#000000';
                            this.ctx.font = '10px Courier New';
                            this.ctx.fillText("Door", x + 6, y + this.TILE - 6);
                        }
                    }
                }
                // Draw player
                const px = 50 + this.playerC * this.TILE;
                const py = offsetY + this.playerR * this.TILE;
                this.ctx.fillStyle = '#00BCD4';
                this.ctx.fillRect(px + 6, py + 6, this.TILE - 12, this.TILE - 12);
                // Draw message
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '14px Courier New';
                this.ctx.fillText(this.message, 10, this.canvas.height - 100);
                this.ctx.fillText("[ARROWS] Move  [SPACE] Interact  [ESC] Leave", 10, this.canvas.height - 80);
                this.ctx.fillText("Step on switches: (1,3), (2,2), (3,1) to open boss door", 10, this.canvas.height - 60);
            }
        }
        // ==================== MAGIC PUZZLE ====================
        class MagicPuzzle {
            constructor(game) {
                this.game = game;
                this.canvas = document.getElementById('magic-puzzle-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.TILE = 40;
                this.rows = 5;
                this.cols = 5;
                this.playerR = 1;
                this.playerC = 1;
                this.cracked = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
                this.bossOpen = false;
                this.message = "";
            }
            onShow() {
                this.reset();
                this.message = "Dungeon: Use Magic to destroy cracked walls!";
                this.render();
            }
            reset() {
                this.cracked[1][3] = true;
                this.cracked[2][2] = true;
                this.cracked[3][1] = true;
                this.bossOpen = false;
                this.playerR = 1;
                this.playerC = 1;
                this.message = "Dungeon reset.";
                this.render();
            }
            handleKeyDown(e) {
                const keyMap = {
                    'ArrowUp': [-1, 0], 'w': [-1, 0], 'W': [-1, 0],
                    'ArrowDown': [1, 0], 's': [1, 0], 'S': [1, 0],
                    'ArrowLeft': [0, -1], 'a': [0, -1], 'A': [0, -1],
                    'ArrowRight': [0, 1], 'd': [0, 1], 'D': [0, 1],
                    ' ': this.interact.bind(this),
                    'Escape': () => this.game.showScreen('overworld'),
                    'i': () => this.game.showScreen('inventory'),
                    'I': () => this.game.showScreen('inventory')
                };
                if (keyMap[e.key]) {
                    if (typeof keyMap[e.key] === 'function') {
                        keyMap[e.key]();
                    } else {
                        this.movePlayer(...keyMap[e.key]);
                    }
                }
            }
            movePlayer(dr, dc) {
                const nr = this.playerR + dr;
                const nc = this.playerC + dc;
                if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols) {
                    this.playerR = nr;
                    this.playerC = nc;
                    this.render();
                }
            }
            interact() {
                console.log('[DEBUG] interact() called');
                if (this.bossOpen && this.playerR === 0 && this.playerC === 2) {
                    this.message = "The Guardian rages! Prepare to fight!";
                    this.render();
                    setTimeout(() => {
                        this.game.showScreen('battle');
                    }, 300);
                    return;
                }
                if (this.cracked[this.playerR][this.playerC]) {
                    const hasMagicSpell = this.game.player.inventory.some(item => item.isSpell());
                    if (hasMagicSpell) {
                        this.cracked[this.playerR][this.playerC] = false;
                        this.game.playSound('magic');
                        this.message = "You cast a spell! The wall crumbles.";
                        this.checkWalls();
                    } else {
                        this.message = "The wall has magic aura. You sense that magic can be used here";
                    }
                    this.render();
                    return;
                }
                this.message = "Nothing to interact with here.";
                this.render();
            }
            checkWalls() {
                if (!this.cracked[1][3] && !this.cracked[2][2] && !this.cracked[3][1]) {
                    this.game.playSound('puzzlesolved');
                    this.bossOpen = true;
                    this.message = "A northern door opens!";
                }
            }
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const offsetY = 20;
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        const x = 50 + c * this.TILE;
                        const y = offsetY + r * this.TILE;
                        this.ctx.fillStyle = '#28283C';
                        this.ctx.fillRect(x, y, this.TILE - 2, this.TILE - 2);
                        if (this.cracked[r][c]) {
                            this.ctx.fillStyle = '#9E9E9E';
                            this.ctx.fillRect(x + 6, y + 6, this.TILE - 12, this.TILE - 12);
                            this.ctx.fillStyle = '#000000';
                            this.ctx.font = '10px Courier New';
                            this.ctx.fillText("Crack", x + 4, y + this.TILE - 8);
                        }
                        if (r === 0 && c === 2) {
                            this.ctx.fillStyle = this.bossOpen ? '#FF9800' : '#424242';
                            this.ctx.fillRect(x + 6, y + 6, this.TILE - 12, this.TILE - 12);
                            this.ctx.fillStyle = '#000000';
                            this.ctx.font = '10px Courier New';
                            this.ctx.fillText("Door", x + 6, y + this.TILE - 6);
                        }
                    }
                }
                // Draw player
                const px = 50 + this.playerC * this.TILE;
                const py = offsetY + this.playerR * this.TILE;
                this.ctx.fillStyle = '#00BCD4';
                this.ctx.fillRect(px + 6, py + 6, this.TILE - 12, this.TILE - 12);
                // Draw message
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '14px Courier New';
                this.ctx.fillText(this.message, 10, this.canvas.height - 100);
                this.ctx.fillText("[ARROWS] Move  [SPACE] Interact  [ESC] Leave", 10, this.canvas.height - 80);
                this.ctx.fillText("Break cracked walls with Magic to open the boss door", 10, this.canvas.height - 60);
            }
        }
        // ==================== DUNGEON STRENGTH ====================
        class DungeonStrength {
            constructor(game) {
                this.game = game;
                this.canvas = document.getElementById('dungeon-strength-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.TILE = 40;
                this.rows = 5;
                this.cols = 5;
                this.playerR = 1;
                this.playerC = 1;
                this.cracked = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
                this.bossOpen = false;
                this.message = "";
            }
            onShow() {
                this.reset();
                this.message = "Dungeon: Smash cracked walls if your strength is high!";
                this.render();
            }
            reset() {
                this.cracked[1][3] = true;
                this.cracked[2][2] = true;
                this.cracked[3][1] = true;
                this.bossOpen = false;
                this.playerR = 1;
                this.playerC = 1;
                this.message = "Dungeon reset.";
                this.render();
            }
            handleKeyDown(e) {
                const keyMap = {
                    'ArrowUp': [-1, 0], 'w': [-1, 0], 'W': [-1, 0],
                    'ArrowDown': [1, 0], 's': [1, 0], 'S': [1, 0],
                    'ArrowLeft': [0, -1], 'a': [0, -1], 'A': [0, -1],
                    'ArrowRight': [0, 1], 'd': [0, 1], 'D': [0, 1],
                    ' ': this.interact.bind(this),
                    'Escape': () => this.game.showScreen('overworld'),
                    'i': () => this.game.showScreen('inventory'),
                    'I': () => this.game.showScreen('inventory')
                };
                if (keyMap[e.key]) {
                    if (typeof keyMap[e.key] === 'function') {
                        keyMap[e.key]();
                    } else {
                        this.movePlayer(...keyMap[e.key]);
                    }
                }
            }
            movePlayer(dr, dc) {
                const nr = this.playerR + dr;
                const nc = this.playerC + dc;
                if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols) {
                    this.playerR = nr;
                    this.playerC = nc;
                    this.render();
                }
            }
            interact() {
                console.log('[DEBUG] interact() called');
                if (this.bossOpen && this.playerR === 0 && this.playerC === 2) {
                    this.message = "The Guardian rages! Prepare to fight!";
                    this.render();
                    setTimeout(() => {
                        this.game.showScreen('battle');
                    }, 300);
                    return;
                }
                if (this.cracked[this.playerR][this.playerC]) {
                    const requiredAtk = 20;
                    if (this.game.player.getAttack() >= requiredAtk) {
                        this.cracked[this.playerR][this.playerC] = false;
                        this.game.playSound('attack');
                        this.message = "You smash through the cracked wall with your strength!";
                        this.checkWalls();
                    } else {
                        this.message = `The wall is weak, but you need more strength (ATK ${requiredAtk}+).`;
                    }
                    this.render();
                    return;
                }
                this.message = "Nothing to interact with here.";
                this.render();
            }
            checkWalls() {
                if (!this.cracked[1][3] && !this.cracked[2][2] && !this.cracked[3][1]) {
                    this.game.playSound('puzzlesolved');
                    this.bossOpen = true;
                    this.message = "A northern door opens!";
                }
            }
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const offsetY = 20;
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        const x = 50 + c * this.TILE;
                        const y = offsetY + r * this.TILE;
                        this.ctx.fillStyle = '#28283C';
                        this.ctx.fillRect(x, y, this.TILE - 2, this.TILE - 2);
                        if (this.cracked[r][c]) {
                            this.ctx.fillStyle = '#9E9E9E';
                            this.ctx.fillRect(x + 6, y + 6, this.TILE - 12, this.TILE - 12);
                            this.ctx.fillStyle = '#000000';
                            this.ctx.font = '10px Courier New';
                            this.ctx.fillText("Crack", x + 4, y + this.TILE - 8);
                        }
                        if (r === 0 && c === 2) {
                            this.ctx.fillStyle = this.bossOpen ? '#FF9800' : '#424242';
                            this.ctx.fillRect(x + 6, y + 6, this.TILE - 12, this.TILE - 12);
                            this.ctx.fillStyle = '#000000';
                            this.ctx.font = '10px Courier New';
                            this.ctx.fillText("Door", x + 6, y + this.TILE - 6);
                        }
                    }
                }
                // Draw player
                const px = 50 + this.playerC * this.TILE;
                const py = offsetY + this.playerR * this.TILE;
                this.ctx.fillStyle = '#00BCD4';
                this.ctx.fillRect(px + 6, py + 6, this.TILE - 12, this.TILE - 12);
                // Draw message
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '14px Courier New';
                this.ctx.fillText(this.message, 10, this.canvas.height - 100);
                this.ctx.fillText("[ARROWS] Move  [SPACE] Interact  [ESC] Leave", 10, this.canvas.height - 80);
                this.ctx.fillText("Break cracked walls with Your Strength to open the boss door", 10, this.canvas.height - 60);
            }
        }
        // ==================== DUNGEON DEFENSE ====================
        class DungeonDefense {
            constructor(game) {
                this.game = game;
                this.canvas = document.getElementById('dungeon-defense-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.TILE = 40;
                this.rows = 5;
                this.cols = 5;
                this.playerR = 1;
                this.playerC = 1;
                this.cracked = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
                this.bossOpen = false;
                this.message = "";
            }
            onShow() {
                this.reset();
                this.message = "Dungeon: Use Willpower to destroy the cracked walls!";
                this.render();
            }
            reset() {
                this.cracked[1][3] = true;
                this.cracked[2][2] = true;
                this.cracked[3][1] = true;
                this.bossOpen = false;
                this.playerR = 1;
                this.playerC = 1;
                this.message = "Dungeon reset.";
                this.render();
            }
            handleKeyDown(e) {
                const keyMap = {
                    'ArrowUp': [-1, 0], 'w': [-1, 0], 'W': [-1, 0],
                    'ArrowDown': [1, 0], 's': [1, 0], 'S': [1, 0],
                    'ArrowLeft': [0, -1], 'a': [0, -1], 'A': [0, -1],
                    'ArrowRight': [0, 1], 'd': [0, 1], 'D': [0, 1],
                    ' ': this.interact.bind(this),
                    'Escape': () => this.game.showScreen('overworld'),
                    'i': () => this.game.showScreen('inventory'),
                    'I': () => this.game.showScreen('inventory')
                };
                if (keyMap[e.key]) {
                    if (typeof keyMap[e.key] === 'function') {
                        keyMap[e.key]();
                    } else {
                        this.movePlayer(...keyMap[e.key]);
                    }
                }
            }
            movePlayer(dr, dc) {
                const nr = this.playerR + dr;
                const nc = this.playerC + dc;
                if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols) {
                    this.playerR = nr;
                    this.playerC = nc;
                    this.render();
                }
            }
            interact() {
                console.log('[DEBUG] interact() called');
                if (this.bossOpen && this.playerR === 0 && this.playerC === 2) {
                    this.message = "The Guardian rages! Prepare to fight!";
                    this.render();
                    setTimeout(() => {
                        this.game.showScreen('battle');
                    }, 300);
                    return;
                }
                if (this.cracked[this.playerR][this.playerC]) {
                    const requiredHp = 100;
                    if (this.game.player.getMaxHP() >= requiredHp) {
                        this.cracked[this.playerR][this.playerC] = false;
                        this.game.playSound('attack');
                        this.message = "You smash through the cracked wall with your Willpower!";
                        this.checkWalls();
                    } else {
                        this.message = `The wall is weak, but you need more Inner Strength (HP ${requiredHp}+).`;
                    }
                    this.render();
                    return;
                }
                this.message = "Nothing to interact with here.";
                this.render();
            }
            checkWalls() {
                if (!this.cracked[1][3] && !this.cracked[2][2] && !this.cracked[3][1]) {
                    this.game.playSound('puzzlesolved');
                    this.bossOpen = true;
                    this.message = "A northern door opens!";
                }
            }
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const offsetY = 20;
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        const x = 50 + c * this.TILE;
                        const y = offsetY + r * this.TILE;
                        this.ctx.fillStyle = '#28283C';
                        this.ctx.fillRect(x, y, this.TILE - 2, this.TILE - 2);
                        if (this.cracked[r][c]) {
                            this.ctx.fillStyle = '#9E9E9E';
                            this.ctx.fillRect(x + 6, y + 6, this.TILE - 12, this.TILE - 12);
                            this.ctx.fillStyle = '#000000';
                            this.ctx.font = '10px Courier New';
                            this.ctx.fillText("Crack", x + 4, y + this.TILE - 8);
                        }
                        if (r === 0 && c === 2) {
                            this.ctx.fillStyle = this.bossOpen ? '#FF9800' : '#424242';
                            this.ctx.fillRect(x + 6, y + 6, this.TILE - 12, this.TILE - 12);
                            this.ctx.fillStyle = '#000000';
                            this.ctx.font = '10px Courier New';
                            this.ctx.fillText("Door", x + 6, y + this.TILE - 6);
                        }
                    }
                }
                // Draw player
                const px = 50 + this.playerC * this.TILE;
                const py = offsetY + this.playerR * this.TILE;
                this.ctx.fillStyle = '#00BCD4';
                this.ctx.fillRect(px + 6, py + 6, this.TILE - 12, this.TILE - 12);
                // Draw message
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '14px Courier New';
                this.ctx.fillText(this.message, 10, this.canvas.height - 100);
                this.ctx.fillText("[ARROWS] Move  [SPACE] Interact  [ESC] Leave", 10, this.canvas.height - 80);
                this.ctx.fillText("Break cracked walls with Your Willpower to open the boss door", 10, this.canvas.height - 60);
            }
        }
        // ==================== DUNGEON BOMB ====================
        class DungeonBomb {
            constructor(game) {
                this.game = game;
                this.canvas = document.getElementById('dungeon-bomb-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.TILE = 40;
                this.rows = 5;
                this.cols = 5;
                this.playerR = 1;
                this.playerC = 1;
                this.cracked = Array(this.rows).fill().map(() => Array(this.cols).fill(false));
                this.bossOpen = false;
                this.message = "";
            }
            onShow() {
                this.reset();
                this.message = "Dungeon: Use bombs to destroy cracked walls!";
                this.render();
            }
            reset() {
                this.cracked[1][3] = true;
                this.cracked[2][2] = true;
                this.cracked[3][1] = true;
                this.bossOpen = false;
                this.playerR = 1;
                this.playerC = 1;
                this.message = "Dungeon reset.";
                this.render();
            }
            handleKeyDown(e) {
                const keyMap = {
                    'ArrowUp': [-1, 0], 'w': [-1, 0], 'W': [-1, 0],
                    'ArrowDown': [1, 0], 's': [1, 0], 'S': [1, 0],
                    'ArrowLeft': [0, -1], 'a': [0, -1], 'A': [0, -1],
                    'ArrowRight': [0, 1], 'd': [0, 1], 'D': [0, 1],
                    ' ': this.interact.bind(this),
                    'Escape': () => this.game.showScreen('overworld'),
                    'i': () => this.game.showScreen('inventory'),
                    'I': () => this.game.showScreen('inventory')
                };
                if (keyMap[e.key]) {
                    if (typeof keyMap[e.key] === 'function') {
                        keyMap[e.key]();
                    } else {
                        this.movePlayer(...keyMap[e.key]);
                    }
                }
            }
            movePlayer(dr, dc) {
                const nr = this.playerR + dr;
                const nc = this.playerC + dc;
                if (nr >= 0 && nr < this.rows && nc >= 0 && nc < this.cols) {
                    this.playerR = nr;
                    this.playerC = nc;
                    this.render();
                }
            }
            interact() {
                console.log('[DEBUG] interact() called');
                if (this.bossOpen && this.playerR === 0 && this.playerC === 2) {
                    this.message = "The Guardian rages! Prepare to fight!";
                    this.render();
                    setTimeout(() => {
                        this.game.showScreen('battle');
                    }, 300);
                    return;
                }
                if (this.cracked[this.playerR][this.playerC]) {
                    const bombToUse = this.game.player.inventory.find(item => item.type === "Bomb");
                    if (bombToUse) {
                        this.cracked[this.playerR][this.playerC] = false;
                        this.game.playSound('bomb');
                        this.game.shake(200, 8);
                        // Remove bomb
                        this.game.player.inventory = this.game.player.inventory.filter(i => i.uniqueId !== bombToUse.uniqueId);
                        this.game.player.equippedBombs = this.game.player.equippedBombs.filter(b => b.uniqueId !== bombToUse.uniqueId);
                        this.message = `You used a ${bombToUse.name}! The wall crumbles.`;
                        this.checkWalls();
                    } else {
                        this.message = "The wall looks weak. Maybe a Bomb could break it.";
                    }
                    this.render();
                    return;
                }
                this.message = "Nothing to interact with here.";
                this.render();
            }
            checkWalls() {
                if (!this.cracked[1][3] && !this.cracked[2][2] && !this.cracked[3][1]) {
                    this.game.playSound('puzzlesolved');
                    this.bossOpen = true;
                    this.message = "A northern door opens!";
                }
            }
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const offsetY = 20;
                for (let r = 0; r < this.rows; r++) {
                    for (let c = 0; c < this.cols; c++) {
                        const x = 50 + c * this.TILE;
                        const y = offsetY + r * this.TILE;
                        this.ctx.fillStyle = '#28283C';
                        this.ctx.fillRect(x, y, this.TILE - 2, this.TILE - 2);
                        if (this.cracked[r][c]) {
                            this.ctx.fillStyle = '#9E9E9E';
                            this.ctx.fillRect(x + 6, y + 6, this.TILE - 12, this.TILE - 12);
                            this.ctx.fillStyle = '#000000';
                            this.ctx.font = '10px Courier New';
                            this.ctx.fillText("Crack", x + 4, y + this.TILE - 8);
                        }
                        if (r === 0 && c === 2) {
                            this.ctx.fillStyle = this.bossOpen ? '#FF9800' : '#424242';
                            this.ctx.fillRect(x + 6, y + 6, this.TILE - 12, this.TILE - 12);
                            this.ctx.fillStyle = '#000000';
                            this.ctx.font = '10px Courier New';
                            this.ctx.fillText("Door", x + 6, y + this.TILE - 6);
                        }
                    }
                }
                // Draw player
                const px = 50 + this.playerC * this.TILE;
                const py = offsetY + this.playerR * this.TILE;
                this.ctx.fillStyle = '#00BCD4';
                this.ctx.fillRect(px + 6, py + 6, this.TILE - 12, this.TILE - 12);
                // Draw message
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '14px Courier New';
                this.ctx.fillText(this.message, 10, this.canvas.height - 100);
                this.ctx.fillText("[ARROWS] Move  [SPACE] Interact  [ESC] Leave", 10, this.canvas.height - 80);
                this.ctx.fillText("Break cracked walls with Bombs to open the boss door", 10, this.canvas.height - 60);
            }
        }
        // ==================== SLAY MAP ====================
        class SlayMap {
            constructor(game) {
                this.game = game;
                this.canvas = document.getElementById('slay-map-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.currentNode = null;
                this.selectedChildIndex = 0;
                this.scrollY = 0;
                this.ROW_HEIGHT = 100;
                this.NODE_RADIUS = 15;
                this.act = 1;
                this.isDraggingScroll = false;
                this.lastMouseY = 0;
            }
            getActNumber() {
                return this.act;
            }
            resetRun() {
                this.act = 1;
                this.generateMap();
                console.log('[DEBUG] SlayMap run reset.');
            }
            startNextAct() {
                this.act++;
                this.generateMap();
            }
            generateMap() {
                this.nodes = [];
                this.selectedChildIndex = 0;
                this.scrollY = 0;
                const totalRows = 10 + (this.act - 1);
                const width = 640;
                let previousRow = [];
                // Start node
                const startNode = new MapNode(0, 0, width / 2, "Start");
                startNode.visited = true;
                this.nodes.push(startNode);
                previousRow.push(startNode);
                this.currentNode = startNode;
                // Middle rows
                for (let r = 1; r < totalRows; r++) {
                    const currentRow = [];
                    const numNodes = 3 + Math.floor(Math.random() * 2);
                    const spacing = width / (numNodes + 1);
                    for (let c = 0; c < numNodes; c++) {
                        const type = this.getRandomTokenType(r);
                        const node = new MapNode(this.nodes.length, r, spacing * (c + 1), type);
                        this.nodes.push(node);
                        currentRow.push(node);
                    }
                    // Connect rows
                    if (r === 1) {
                        const start = previousRow[0];
                        currentRow.forEach(child => {
                            start.children.push(child);
                            child.parents.push(start);
                        });
                    } else {
                        this.connectRows(previousRow, currentRow);
                    }
                    previousRow = currentRow;
                }
                // Boss node
                const bossNode = new MapNode(this.nodes.length, totalRows, width / 2, "Boss");
                this.nodes.push(bossNode);
                previousRow.forEach(n => {
                    n.children.push(bossNode);
                    bossNode.parents.push(n);
                });
            }
            getRandomTokenType(row) {
                const roll = Math.floor(Math.random() * 100);
                if (roll < 10) return "Rest";
                if (roll < 60) return "Unknown";
                if (roll < 70) return "Treasure";
                return "Enemy";
            }
            connectRows(parents, children) {
                parents.forEach(p => {
                    children.forEach(c => {
                        const dist = Math.abs(p.col - c.col);
                        if (dist < 150) {
                            p.children.push(c);
                            c.parents.push(p);
                        }
                    });
                    if (p.children.length === 0) {
                        const fallback = children[Math.floor(Math.random() * children.length)];
                        p.children.push(fallback);
                        fallback.parents.push(p);
                    }
                });
            }
            moveToNode(node) {
                this.currentNode.visited = true;
                this.currentNode = node;
                this.selectedChildIndex = 0;
                // Auto-scroll
                const nodeY = node.row * this.ROW_HEIGHT;
                this.setScroll(nodeY - 150);
                this.game.returnScreen = 'slay-map';
                switch (node.type) {
                    case "Enemy":
                        this.game.showScreen('battle');
                        break;
                    case "Boss":
                        // Set boss pending
                        this.game.showScreen('battle');
                        break;
                    case "Rest":
                        const heal = Math.floor(this.game.player.getMaxHP() * 0.5);
                        this.game.player.currentHP = Math.min(this.game.player.getMaxHP(), this.game.player.currentHP + heal);
                        alert(`You rested and healed ${heal} HP.`);
                        break;
                    case "Treasure":
                        const loot = this.createRandomGear(this.game.player.level);
                        this.game.player.addItem(loot);
                        alert(`Found loot: ${loot.name}`);
                        break;
                    case "Unknown":
                        if (Math.random() < 0.5) {
                            alert("It's a trap!");
                            this.game.showScreen('battle');
                        } else {
                            const gold = 50 + Math.floor(Math.random() * 50);
                            this.game.player.gold += gold;
                            alert(`Found ${gold} gold!`);
                        }
                        break;
                }
            }
            createRandomGear(playerLevel) {
                const roll = Math.floor(Math.random() * 100);
                if (playerLevel <= 2) {
                    return roll < 70 ?
                        new Item("Bronze Sword", 300, false, true, 0, 5, 0, "Weapon", null) :
                        new Item("Bronze Armor", 300, false, true, 0, 0, 10, "Armor", null);
                } else if (playerLevel <= 5) {
                    if (roll < 40) return new Item("Iron Sword", 800, false, true, 0, 10, 0, "Weapon", null);
                    if (roll < 80) return new Item("Iron Armor", 800, false, true, 0, 0, 15, "Armor", null);
                    return new Item("Gold Sword", 1500, false, true, 0, 15, 0, "Weapon", null);
                } else if (playerLevel <= 8) {
                    if (roll < 50) return new Item("Gold Sword", 1500, false, true, 0, 10, 0, "Weapon", null);
                    if (roll < 80) return new Item("Gold Armor", 1500, false, true, 0, 0, 25, "Armor", null);
                    return new Item("Diamond Sword", 2000, false, true, 0, 25, 0, "Weapon", null);
                } else {
                    if (roll < 40) return new Item("Diamond Sword", 2000, false, true, 0, 25, 0, "Weapon", null);
                    return new Item("Diamond Armor", 2000, false, true, 0, 0, 100, "Armor", null);
                }
            }
            onShow() {
                this.render();
            }
            handleKeyDown(e) {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    if (this.currentNode && this.currentNode.children.length > 0) {
                        this.selectedChildIndex--;
                        if (this.selectedChildIndex < 0) this.selectedChildIndex = this.currentNode.children.length - 1;
                        this.render();
                    }
                } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    if (this.currentNode && this.currentNode.children.length > 0) {
                        this.selectedChildIndex++;
                        if (this.selectedChildIndex >= this.currentNode.children.length) this.selectedChildIndex = 0;
                        this.render();
                    }
                } else if (e.key === 'Enter' || e.key === ' ') {
                    if (this.currentNode && this.currentNode.children.length > 0) {
                        const target = this.currentNode.children[this.selectedChildIndex];
                        this.moveToNode(target);
                    }
                } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                    this.setScroll(this.scrollY + 30);
                } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                    this.setScroll(this.scrollY - 30);
                } else if (e.key === 'i' || e.key === 'I') {
                    this.game.showScreen('inventory');
                } else if (e.key === 'p' || e.key === 'P') {
                    this.game.lastScreen = 'slay-map';
                    this.game.showScreen('shop');
                }
            }
            handleWheel(e) {
                const scrollAmount = e.deltaY;
                this.setScroll(this.scrollY - scrollAmount * 0.5);
            }
            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                // Check if clicked on scrollbar
                if (mouseX > this.canvas.width - 20) {
                    this.isDraggingScroll = true;
                    this.lastMouseY = mouseY;
                    return;
                }
                // Check if clicked on a node
                if (this.currentNode && this.currentNode.children.length > 0) {
                    const viewHeight = this.canvas.height;
                    const baseLineY = viewHeight - 80;
                    for (let i = 0; i < this.currentNode.children.length; i++) {
                        const child = this.currentNode.children[i];
                        const nodeX = child.col;
                        const nodeY = baseLineY - (child.row * this.ROW_HEIGHT) + this.scrollY;
                        const dist = Math.sqrt(Math.pow(mouseX - nodeX, 2) + Math.pow(mouseY - nodeY, 2));
                        if (dist < 30) {
                            this.selectedChildIndex = i;
                            this.moveToNode(child);
                            return;
                        }
                    }
                }
            }
            render() {
                const g = this.ctx;
                g.clearRect(0, 0, this.canvas.width, this.canvas.height);
                const viewHeight = this.canvas.height;
                const virtualHeight = this.getVirtualHeight();
                // Draw map background
                g.fillStyle = '#281C14';
                g.fillRect(0, 0, this.canvas.width, this.canvas.height);
                // Draw connections
                g.strokeStyle = '#645040';
                g.lineWidth = 2;
                g.lineCap = 'round';
                g.lineJoin = 'round';
                for (const node of this.nodes) {
                    const myY = viewHeight - 80 - (node.row * this.ROW_HEIGHT) + this.scrollY;
                    for (const child of node.children) {
                        const childY = viewHeight - 80 - (child.row * this.ROW_HEIGHT) + this.scrollY;
                        g.beginPath();
                        g.moveTo(node.col, myY);
                        g.lineTo(child.col, childY);
                        g.stroke();
                    }
                }
                // Draw nodes
                for (const node of this.nodes) {
                    const y = viewHeight - 80 - (node.row * this.ROW_HEIGHT) + this.scrollY;
                    const x = node.col;
                    // Skip if off-screen
                    if (y < -50 || y > viewHeight + 50) continue;
                    // Set color based on type
                    if (node.type === "Enemy") g.fillStyle = '#4A4A4A';
                    else if (node.type === "Rest") g.fillStyle = '#FFA500';
                    else if (node.type === "Treasure") g.fillStyle = '#FFD700';
                    else if (node.type === "Boss") g.fillStyle = '#FF0000';
                    else if (node.type === "Start") g.fillStyle = '#00FF00';
                    else g.fillStyle = '#C0C0C0';
                    // Darken if visited but not current
                    if (node.visited && node !== this.currentNode) {
                        g.fillStyle = this.darkenColor(g.fillStyle);
                    }
                    // Draw node
                    g.beginPath();
                    g.arc(x, y, this.NODE_RADIUS, 0, Math.PI * 2);
                    g.fill();
                    // Draw outline
                    g.strokeStyle = node === this.currentNode ? '#00FFFF' : '#000000';
                    g.lineWidth = node === this.currentNode ? 3 : 1;
                    g.stroke();
                    // Draw player pawn on current node
                    if (node === this.currentNode) {
                        g.fillStyle = '#0000FF';
                        g.fillRect(x - 5, y - 15, 10, 10);
                    }
                    // Draw type letter
                    g.fillStyle = '#FFFFFF';
                    g.font = '12px Courier New';
                    g.textAlign = 'center';
                    g.textBaseline = 'middle';
                    const letter = node.type === "Unknown" ? "?" : node.type.charAt(0);
                    g.fillText(letter, x, y);
                }
                // Draw selection highlight
                if (this.currentNode && this.currentNode.children.length > 0) {
                    const target = this.currentNode.children[this.selectedChildIndex];
                    const targetY = viewHeight - 80 - (target.row * this.ROW_HEIGHT) + this.scrollY;
                    if (targetY > 0 && targetY < viewHeight) {
                        g.strokeStyle = '#00FF00';
                        g.lineWidth = 3;
                        g.beginPath();
                        g.arc(target.col, targetY, this.NODE_RADIUS + 4, 0, Math.PI * 2);
                        g.stroke();
                    }
                }
                // Draw scrollbar
                if (virtualHeight > viewHeight) {
                    const barWidth = 16;
                    const barX = this.canvas.width - barWidth - 2;
                    // Track
                    g.fillStyle = '#1E1E1E';
                    g.fillRect(barX, 0, barWidth, viewHeight);
                    // Slider
                    const sliderHeight = Math.max(30, Math.floor((viewHeight / virtualHeight) * viewHeight));
                    const maxScroll = virtualHeight - viewHeight;
                    const maxSliderY = viewHeight - sliderHeight;
                    const sliderY = maxScroll > 0 ? Math.floor((this.scrollY / maxScroll) * maxSliderY) : 0;
                    g.fillStyle = this.isDraggingScroll ? '#808080' : '#C0C0C0';
                    g.fillRect(barX + 2, sliderY, barWidth - 4, sliderHeight);
                }
                // Draw HUD
                g.fillStyle = 'rgba(0, 0, 0, 0.6)';
                g.fillRect(0, 0, this.canvas.width - 20, 40);
                g.fillStyle = '#FFFFFF';
                g.font = '14px Courier New';
                g.textAlign = 'left';
                g.fillText(`Act ${this.act} | Scroll: Mouse Wheel | Select: Arrows + Space | I: Inventory | P: Shop`, 10, 25);
            }
            getVirtualHeight() {
                const totalRows = 10 + (this.act - 1);
                return totalRows * this.ROW_HEIGHT + 200;
            }
            darkenColor(color) {
                // Simple darkening for visited nodes
                return '#333333';
            }
            save() {
                return {
                    act: this.act,
                    currentNodeId: this.currentNode ? this.currentNode.id : 0
                };
            }
            load(data) {
                if (data.act) {
                    this.act = data.act;
                    this.generateMap();
                }
            }
        }
        // ==================== MAP NODE ====================
        class MapNode {
            constructor(id, row, col, type) {
                this.id = id;
                this.row = row;
                this.col = col;
                this.type = type;
                this.visited = false;
                this.parents = [];
                this.children = [];
            }
        }
        // ==================== VICTORY SCREEN ====================
        class VictoryScreen {
            constructor(game) {
                this.game = game;
            }
            onShow() {
                console.log('[DEBUG] Victory screen shown');
            }
        }
        // ==================== GAME BEAT SCREEN ====================
        class GameBeatScreen {
            constructor(game) {
                this.game = game;
            }
            onShow() {
                console.log('[DEBUG] Game Beat screen shown');
            }
        }
        // ==================== SLAY ACT CLEAR SCREEN ====================
        class SlayActClearScreen {
            constructor(game) {
                this.game = game;
            }
            onShow() {
                // Heal player as reward
                const heal = 30;
                this.game.player.currentHP = Math.min(this.game.player.getMaxHP(), this.game.player.currentHP + heal);
                document.getElementById('act-clear-info').textContent =
                    `HP Restored! Ready for Act ${this.game.slayMap.getActNumber() + 1}?`;
            }
        }
        // ==================== DUNGEON LAUNCH ====================
        class DungeonLaunch {
            static bossPending = false;
            static setBossPending(b) {
                this.bossPending = b;
            }
            static isBossPending() {
                return this.bossPending;
            }
            static clear() {
                this.bossPending = false;
            }
        }
        // ==================== INITIALIZE GAME ====================
        const game = new Game();
        // Auto-save every 30 seconds
        setInterval(() => {
            game.saveGame();
        }, 30000);
        console.log('Dungeon Legends loaded successfully!');
    </script>
</body>

</html>